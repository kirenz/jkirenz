<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Statistics on Jan Kirenz</title>
    <link>/tags/statistics/</link>
    <description>Recent content in Statistics on Jan Kirenz</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <copyright>&amp;copy; Jan Kirenz, {year}</copyright>
    <lastBuildDate>Mon, 30 Sep 2019 00:00:00 +0000</lastBuildDate>
    
	    <atom:link href="/tags/statistics/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Applied Statistics</title>
      <link>/talk/2019-applied-statistics/</link>
      <pubDate>Mon, 30 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/talk/2019-applied-statistics/</guid>
<<<<<<< HEAD
      <description>



</description>
=======
      <description></description>
>>>>>>> 5b4f11a004ab5d532500113c7a94cd15366cfa9b
    </item>
    
    <item>
      <title>Text Mining in R</title>
      <link>/post/2019-09-16-r-text-mining/</link>
      <pubDate>Mon, 16 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-09-16-r-text-mining/</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction-to-textmining-in-r&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1&lt;/span&gt; Introduction to Textmining in R&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#installation-of-r-packages&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.1&lt;/span&gt; Installation of R packages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#data-import&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.2&lt;/span&gt; Data import&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#data-transformation&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2&lt;/span&gt; Data transformation&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#tokenization&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.1&lt;/span&gt; Tokenization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stop-words&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.2&lt;/span&gt; Stop words&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exploratory-data-analysis&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3&lt;/span&gt; Exploratory data analysis&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#term-frequency-tf&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.1&lt;/span&gt; Term frequency (tf)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#term-frequency-and-inverse-document-frequency-tf-idf&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.2&lt;/span&gt; Term frequency and inverse document frequency (tf-idf)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tokenizing-by-n-gram&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.3&lt;/span&gt; Tokenizing by n-gram&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#network-analysis&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.4&lt;/span&gt; Network analysis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#classification-with-logistic-regression&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4&lt;/span&gt; Classification with logistic regression&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#train-test-split&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.1&lt;/span&gt; Train test split&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#training-data-sparse-matrix&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.2&lt;/span&gt; Training data (sparse matrix)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#response-variable&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.3&lt;/span&gt; Response variable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#logistic-regression-model&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.4&lt;/span&gt; Logistic regression model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#model-evaluation-with-test-data&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.5&lt;/span&gt; Model evaluation with test data&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;introduction-to-textmining-in-r&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;1&lt;/span&gt; Introduction to Textmining in R&lt;/h1&gt;
&lt;p&gt;This post demonstrates how various R packages can be used for text mining in R. In particular, we start with common text transformations, perform various data explorations with term frequency (tf) and inverse document frequency (idf) and build a supervised classifiaction model that learns the difference between texts of different authors.&lt;/p&gt;
&lt;p&gt;The content of this tutorial is based on the excellent book &lt;a href=&#34;https://www.tidytextmining.com&#34;&gt;“Textmining with R (2019)”&lt;/a&gt; from Julia Silge and David Robinson and the blog post &lt;a href=&#34;https://www.r-bloggers.com/text-classification-with-tidy-data-principles/&#34;&gt;“Text classification with tidy data principles (2018)”&lt;/a&gt; from Julia Silges.&lt;/p&gt;
&lt;div id=&#34;installation-of-r-packages&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.1&lt;/span&gt; Installation of R packages&lt;/h2&gt;
&lt;p&gt;If you like to install all packages at once, use the code below.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(c(&amp;quot;dplyr&amp;quot;, &amp;quot;gutenbergr&amp;quot;, &amp;quot;stringr&amp;quot;, &amp;quot;tidytext&amp;quot;, &amp;quot;tidyr&amp;quot;,
                   &amp;quot;stopwords&amp;quot;, &amp;quot;wordcloud&amp;quot;, &amp;quot;rsample&amp;quot;, &amp;quot;glmnet&amp;quot;, 
                   &amp;quot;doMC&amp;quot;, &amp;quot;forcats&amp;quot;, &amp;quot;broom&amp;quot;, &amp;quot;igraph&amp;quot;, &amp;quot;ggraph&amp;quot;)) &lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;data-import&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.2&lt;/span&gt; Data import&lt;/h2&gt;
&lt;p&gt;We can access the full texts of various books from “Project Gutenberg” via the &lt;a href=&#34;https://cran.r-project.org/web/packages/gutenbergr/vignettes/intro.html&#34;&gt;&lt;code&gt;gutenbergr&lt;/code&gt; package&lt;/a&gt;. We can look up certain authors or titles with a regular expression using the &lt;code&gt;stringr&lt;/code&gt; package. All functions in &lt;code&gt;stringr&lt;/code&gt; start with &lt;code&gt;str_&lt;/code&gt;and take a vector of strings as the first argument. To learn more about stringr, visit the &lt;a href=&#34;https://stringr.tidyverse.org&#34;&gt;stringr documentation&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(gutenbergr)
library(stringr)

doyle &amp;lt;- gutenberg_works(str_detect(author, &amp;quot;Doyle&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table table-striped table-hover table-condensed table-responsive&#34; style=&#34;margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
gutenberg_id
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
title
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
author
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
gutenberg_author_id
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
language
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
gutenberg_bookshelf
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
rights
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
has_text
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
108
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
The Return of Sherlock Holmes
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Doyle, Arthur Conan
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
69
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
en
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Detective Fiction
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Public domain in the USA.
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
TRUE
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
126
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
The Poison Belt
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Doyle, Arthur Conan
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
69
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
en
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Science Fiction
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Public domain in the USA.
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
TRUE
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
139
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
The Lost World
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Doyle, Arthur Conan
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
69
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
en
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Science Fiction
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Public domain in the USA.
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
TRUE
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
244
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
A Study in Scarlet
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Doyle, Arthur Conan
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
69
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
en
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Detective Fiction
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Public domain in the USA.
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
TRUE
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;We obtain &lt;em&gt;“Relativity: The Special and General Theory”&lt;/em&gt; by Albert Einstein (gutenberg_id: 30155) and &lt;em&gt;“Experiments with Alternate Currents of High Potential and High Frequency”&lt;/em&gt; by Nikola Tesla (gutenberg_id: 13476) from gutenberg and add the column “author” to the result.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(gutenbergr)

books &amp;lt;- gutenberg_download(c(30155, 13476), meta_fields = &amp;quot;author&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Furthermore, we transfrom the data to a &lt;a href=&#34;https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html&#34;&gt;tibble&lt;/a&gt; (tibbles are a modern take on data frames), add the row number with the column name &lt;code&gt;document&lt;/code&gt; to the tibble and drop the column &lt;code&gt;gutenberg_id&lt;/code&gt;. We will use the information in column &lt;code&gt;document&lt;/code&gt; to train a model that can take an individual line (row) and give us a probability that the text in this particular line comes from a certain author.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dplyr)

books &amp;lt;- as_tibble(books) %&amp;gt;% 
  mutate(document = row_number()) %&amp;gt;% 
  select(-gutenberg_id)&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table table-striped table-hover table-condensed table-responsive&#34; style=&#34;margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
text
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
author
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
document
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
EXPERIMENTS WITH ALTERNATE CURRENTS OF HIGH POTENTIAL AND HIGH FREQUENCY
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
2
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
A Lecture Delivered before the Institution of Electrical Engineers, London
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
3
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
4
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
by
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
5
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
6
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
NIKOLA TESLA
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
7
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
8
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;data-transformation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;2&lt;/span&gt; Data transformation&lt;/h1&gt;
&lt;div id=&#34;tokenization&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.1&lt;/span&gt; Tokenization&lt;/h2&gt;
&lt;p&gt;First of all, we need to both break the text into individual tokens (a process called &lt;strong&gt;tokenization&lt;/strong&gt;) and transform it to a tidy data structure (i.e. each variable must have its own column, each observation must have its own row and each value must have its own cell). To do this, we use tidytext’s &lt;code&gt;unnest_tokens()&lt;/code&gt; function. We also remove the &lt;em&gt;rarest words&lt;/em&gt; in that step, keeping only words in our dataset that occur more than 10 times.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dplyr)
library(tidytext)

tidy_books &amp;lt;- books %&amp;gt;%
  unnest_tokens(word, text) %&amp;gt;%
  group_by(word) %&amp;gt;%
  filter(n() &amp;gt; 10) %&amp;gt;%
  ungroup()&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table table-striped table-hover table-condensed table-responsive&#34; style=&#34;margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
author
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
document
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
word
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
experiments
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
with
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
alternate
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
currents
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
of
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
high
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
potential
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
and
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div id=&#34;stop-words&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.2&lt;/span&gt; Stop words&lt;/h2&gt;
&lt;p&gt;Now that the data is in a tidy “one-word-per-row” format, we can manipulate it with packages like &lt;code&gt;dplyr&lt;/code&gt;. Often in text analysis, we will want to remove &lt;strong&gt;stop words&lt;/strong&gt;: Stop words are words that are not useful for an analysis, typically extremely common words such as “the”, “of”, “to”, and so forth. We can remove stop words in our data by using the stop words provided in the package &lt;code&gt;stopwords&lt;/code&gt; with an &lt;code&gt;anti_join()&lt;/code&gt; from the package &lt;code&gt;dplyr&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(stopwords) 
library(dplyr)
library(tibble)

stopword &amp;lt;- as_tibble(stopwords::stopwords(&amp;quot;en&amp;quot;)) 
stopword &amp;lt;- rename(stopword, word=value)
tb &amp;lt;- anti_join(tidy_books, stopword, by = &amp;#39;word&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table table-striped table-hover table-condensed table-responsive&#34; style=&#34;margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
author
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
document
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
word
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
experiments
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
alternate
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
currents
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
high
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
potential
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
high
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
frequency
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
3
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
lecture
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The tidy data structure allows different types of exploratory data analysis (EDA), which we turn to next.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;exploratory-data-analysis&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;3&lt;/span&gt; Exploratory data analysis&lt;/h1&gt;
&lt;div id=&#34;term-frequency-tf&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.1&lt;/span&gt; Term frequency (tf)&lt;/h2&gt;
&lt;p&gt;An important question in text mining is how to quantify what a document is about. One measure of how important a word may be is its &lt;strong&gt;term frequency&lt;/strong&gt; (tf), i.e. how frequently a word occurs in a document.&lt;/p&gt;
&lt;p&gt;We can start by using &lt;code&gt;dplyr&lt;/code&gt; to explore the most commonly used words.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dplyr)

word_count &amp;lt;- count(tb, word, sort = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table table-striped table-hover table-condensed table-responsive&#34; style=&#34;margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
word
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
n
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
one
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
239
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
body
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
230
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
may
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
224
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
can
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
194
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
relativity
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
193
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Term frequency by author:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dplyr)

author_count &amp;lt;-  tb %&amp;gt;% 
  count(author, word, sort = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table table-striped table-hover table-condensed table-responsive&#34; style=&#34;margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
author
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
word
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
n
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Einstein, Albert
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
relativity
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
193
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
may
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
184
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Einstein, Albert
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
theory
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
181
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
bulb
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
171
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
coil
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
166
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
high
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
166
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Einstein, Albert
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
body
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
156
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
one
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
156
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Einstein, Albert
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
reference
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
150
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
tube
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
147
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Plot terms with a frequency greater than 100:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dplyr)
library(ggplot2)

tb %&amp;gt;%
  count(author, word, sort = TRUE) %&amp;gt;%
  filter(n &amp;gt; 100) %&amp;gt;%
  mutate(word = reorder(word, n)) %&amp;gt;%
  ggplot(aes(word, n)) +
  geom_col(aes(fill=author)) +
  xlab(NULL) +
  scale_y_continuous(expand = c(0, 0)) +
  coord_flip() +
  theme_classic(base_size = 12) +
  labs(fill= &amp;quot;Author&amp;quot;, title=&amp;quot;Word frequency&amp;quot;, subtitle=&amp;quot;n &amp;gt; 100&amp;quot;)+
  theme(plot.title = element_text(lineheight=.8, face=&amp;quot;bold&amp;quot;)) +
  scale_fill_brewer() &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-09-16-r-text-mining/index_files/figure-html/unnamed-chunk-15-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Plot top 20 terms by author:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)

tb %&amp;gt;%
  count(author, word, sort = TRUE) %&amp;gt;%
  group_by(author) %&amp;gt;%
  top_n(20) %&amp;gt;%
  ungroup() %&amp;gt;%
  ggplot(aes(reorder_within(word, n, author), n,
    fill = author)) +
  geom_col(alpha = 0.8, show.legend = FALSE) +
  scale_x_reordered() +
  coord_flip() +
  facet_wrap(~author, scales = &amp;quot;free&amp;quot;) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_classic(base_size = 12) +
  labs(fill= &amp;quot;Author&amp;quot;, 
       title=&amp;quot;Most frequent words&amp;quot;, 
       subtitle=&amp;quot;Top 20 words by book&amp;quot;,
       x= NULL, 
       y= &amp;quot;Word Count&amp;quot;)+
  theme(plot.title = element_text(lineheight=.8, face=&amp;quot;bold&amp;quot;)) +
  scale_fill_brewer()   &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-09-16-r-text-mining/index_files/figure-html/unnamed-chunk-16-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;You may notice expressions like “_k”, “co” in the Einstein text and “fig” in the Tesla text. Let’s remove these and other less meaningful words with a custom list of stop words and use anti_join() to remove them.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;newstopwords &amp;lt;- tibble(word = c(&amp;quot;eq&amp;quot;, &amp;quot;co&amp;quot;, &amp;quot;rc&amp;quot;, &amp;quot;ac&amp;quot;, &amp;quot;ak&amp;quot;, &amp;quot;bn&amp;quot;, 
                                   &amp;quot;fig&amp;quot;, &amp;quot;file&amp;quot;, &amp;quot;cg&amp;quot;, &amp;quot;cb&amp;quot;, &amp;quot;cm&amp;quot;,
                               &amp;quot;ab&amp;quot;, &amp;quot;_k&amp;quot;, &amp;quot;_k_&amp;quot;, &amp;quot;_x&amp;quot;))

tb &amp;lt;- anti_join(tb, newstopwords, by = &amp;quot;word&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we plot the data again without the new stopwords:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)

tb %&amp;gt;%
  count(author, word, sort = TRUE) %&amp;gt;%
  group_by(author) %&amp;gt;%
  top_n(20) %&amp;gt;%
  ungroup() %&amp;gt;%
  ggplot(aes(reorder_within(word, n, author), n,
    fill = author)) +
  geom_col(alpha = 0.8, show.legend = FALSE) +
  scale_x_reordered() +
  coord_flip() +
  facet_wrap(~author, scales = &amp;quot;free&amp;quot;) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_classic(base_size = 12) +
  labs(fill= &amp;quot;Author&amp;quot;, 
       title=&amp;quot;Most frequent words after removing stop words&amp;quot;, 
       subtitle=&amp;quot;Top 20 words by book&amp;quot;,
       x= NULL, 
       y= &amp;quot;Word Count&amp;quot;)+
  theme(plot.title = element_text(lineheight=.8, face=&amp;quot;bold&amp;quot;)) +
  scale_fill_brewer()   &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-09-16-r-text-mining/index_files/figure-html/unnamed-chunk-18-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;You also may want to visualize the most frequent terms as a simple word cloud:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(wordcloud)

tb %&amp;gt;%
  count(word) %&amp;gt;%
  with(wordcloud(word, n, max.words = 15))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-09-16-r-text-mining/index_files/figure-html/unnamed-chunk-19-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;term-frequency-and-inverse-document-frequency-tf-idf&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.2&lt;/span&gt; Term frequency and inverse document frequency (tf-idf)&lt;/h2&gt;
&lt;p&gt;Term frequency is a useful measure to determine how frequently a word occurs in a document. There are words in a document, however, that occur many times but may not be important.&lt;/p&gt;
&lt;p&gt;Another approach is to look at a term’s &lt;strong&gt;inverse document frequency (idf)&lt;/strong&gt;, which decreases the weight for commonly used words and increases the weight for words that are not used very much in a collection of documents. This can be combined with term frequency to calculate a term’s tf-idf (the two quantities multiplied together), the frequency of a term adjusted for how rarely it is used.&lt;/p&gt;
&lt;p&gt;The inverse document frequency for any given term is defined as:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[idf(\text{term}) = \ln{\left(\frac{n_{\text{documents}}}{n_{\text{documents containing term}}}\right)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Hence, term frequency and inverse document frequency allows us to find words that are characteristic for one document within a collection of documents. The &lt;code&gt;tidytext&lt;/code&gt; package uses an implementation of tf-idf consistent with tidy data principles that enables us to see how different words are important in documents within a collection or corpus of documents.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(forcats)

plot_tb &amp;lt;- tb %&amp;gt;%
  count(author, word, sort = TRUE) %&amp;gt;%
  bind_tf_idf(word, author, n) %&amp;gt;%
  mutate(word = fct_reorder(word, tf_idf)) %&amp;gt;%
  mutate(author = factor(author, 
                         levels = c(&amp;quot;Tesla, Nikola&amp;quot;,
                                    &amp;quot;Einstein, Albert&amp;quot;)))

plot_tb %&amp;gt;% 
  group_by(author) %&amp;gt;% 
  top_n(15, tf_idf) %&amp;gt;% 
  ungroup() %&amp;gt;%
  mutate(word = reorder(word, tf_idf)) %&amp;gt;%
  ggplot(aes(word, tf_idf, fill = author)) +
  scale_y_continuous(expand = c(0, 0)) +
  geom_col(show.legend = FALSE) +
  labs(x = NULL, y = &amp;quot;tf-idf&amp;quot;) +
  facet_wrap(~author, ncol = 2, scales = &amp;quot;free&amp;quot;) +
  coord_flip() +
  theme_classic(base_size = 12) +
  labs(fill= &amp;quot;Author&amp;quot;, 
       title=&amp;quot;Term frequency and inverse document frequency (tf-idf)&amp;quot;, 
       subtitle=&amp;quot;Top 20 words by book&amp;quot;,
       x= NULL, 
       y= &amp;quot;tf-idf&amp;quot;) +
  theme(plot.title = element_text(lineheight=.8, face=&amp;quot;bold&amp;quot;)) +
  scale_fill_brewer()  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-09-16-r-text-mining/index_files/figure-html/unnamed-chunk-20-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;In particular, the &lt;code&gt;bind_tf_idf&lt;/code&gt; function in the &lt;code&gt;tidytext&lt;/code&gt; package takes a tidy text dataset as input with one row per token (term), per document. One column (word here) contains the terms/tokens, one column contains the documents (authors in this case), and the last necessary column contains the counts, how many times each document contains each term (n in this example).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tf_idf &amp;lt;- tb %&amp;gt;%
  count(author, word, sort = TRUE) %&amp;gt;%
  bind_tf_idf(word, author, n)&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table table-striped table-hover table-condensed table-responsive&#34; style=&#34;margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
author
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
word
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
n
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
tf
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
idf
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
tf_idf
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Einstein, Albert
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
relativity
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
193
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0177831
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.6931472
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0123263
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
may
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
184
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0139436
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0000000
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0000000
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Einstein, Albert
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
theory
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
181
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0166774
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.6931472
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0115599
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
bulb
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
171
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0129585
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.6931472
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0089821
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
coil
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
166
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0125796
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.6931472
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0087195
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
high
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
166
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0125796
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0000000
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0000000
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Einstein, Albert
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
body
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
156
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0143739
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0000000
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0000000
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
one
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
156
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0118218
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0000000
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0000000
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Einstein, Albert
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
reference
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
150
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0138211
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0000000
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0000000
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
tube
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
147
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0111397
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0000000
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0000000
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Notice that &lt;em&gt;idf&lt;/em&gt; and thus &lt;em&gt;tf-idf&lt;/em&gt; are zero for extremely common words (like “may”). These are all words that appear in both documents, so the idf term (which will then be the natural log of 1) is zero. The inverse document frequency (and thus tf-idf) is very low (near zero) for words that occur in many of the documents in a collection; this is how this approach decreases the weight for common words. The inverse document frequency will be a higher number for words that occur in fewer of the documents in the collection.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;tokenizing-by-n-gram&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.3&lt;/span&gt; Tokenizing by n-gram&lt;/h2&gt;
&lt;p&gt;We’ve been using the &lt;code&gt;unnest_tokens&lt;/code&gt; function to tokenize by word, or sometimes by sentence, which is useful for the kinds of frequency analyses we’ve been doing so far. But we can also use the function to tokenize into consecutive sequences of words, called &lt;strong&gt;n-grams&lt;/strong&gt;. By seeing how often word X is followed by word Y, we can then build a model of the relationships between them.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dplyr)
library(tidytext)

einstein_bigrams &amp;lt;- books %&amp;gt;%
  filter(author == &amp;quot;Einstein, Albert&amp;quot;) %&amp;gt;% 
  unnest_tokens(bigram, text, token = &amp;quot;ngrams&amp;quot;, n = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table table-striped table-hover table-condensed table-responsive&#34; style=&#34;margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
author
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
document
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
bigram
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Einstein, Albert
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
3797
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
NA
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Einstein, Albert
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
3798
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
NA
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Einstein, Albert
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
3799
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
NA
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Einstein, Albert
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
3800
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
NA
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Einstein, Albert
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
3801
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
relativity the
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Einstein, Albert
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
3801
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
the special
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Einstein, Albert
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
3801
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
special and
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Einstein, Albert
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
3801
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
and general
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Einstein, Albert
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
3801
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
general theory
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Einstein, Albert
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
3802
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
NA
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;We can examine the most common bigrams using dplyr’s &lt;code&gt;count()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;einstein_bigrams_count &amp;lt;- einstein_bigrams %&amp;gt;% 
    count(bigram, sort = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table table-striped table-hover table-condensed table-responsive&#34; style=&#34;margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
bigram
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
n
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
NA
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
916
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
of the
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
613
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
to the
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
247
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
in the
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
197
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
of relativity
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
164
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
theory of
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
121
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
with the
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
119
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
on the
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
111
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
that the
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
110
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
of a
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
98
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Now we use tidyr’s &lt;code&gt;separate()&lt;/code&gt;, which splits a column into multiple columns based on a delimiter. This lets us separate it into two columns, “word1” and “word2”, at which point we can remove cases where either is a stop-word. This time, we use the stopwords from the package &lt;code&gt;tidyr&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyr)

# seperate words
bigrams_separated &amp;lt;- einstein_bigrams %&amp;gt;%
  separate(bigram, c(&amp;quot;word1&amp;quot;, &amp;quot;word2&amp;quot;), sep = &amp;quot; &amp;quot;)

# filter stop words and NA
bigrams_filtered &amp;lt;- bigrams_separated %&amp;gt;%
  filter(!word1 %in% stop_words$word) %&amp;gt;%
  filter(!word2 %in% stop_words$word) %&amp;gt;% 
  filter(!is.na(word1))

# new bigram counts:
bigram_counts &amp;lt;- bigrams_filtered %&amp;gt;% 
  count(word1, word2, sort = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table table-striped table-hover table-condensed table-responsive&#34; style=&#34;margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
word1
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
word2
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
n
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
reference
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
body
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
56
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
gravitational
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
field
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
53
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
special
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
theory
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
35
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
ordinate
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
system
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
34
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
space
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
time
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
27
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
classical
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
mechanics
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
26
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
lorentz
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
transformation
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
23
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
measuring
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
rods
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
22
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
straight
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
line
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
17
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
rigid
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
body
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
16
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;This one-bigram-per-row format is helpful for exploratory analyses of the text. As a simple example, we might be interested in the most often mentioned “theory”:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bigram_theory &amp;lt;- bigrams_filtered %&amp;gt;%
  filter(word2 == &amp;quot;theory&amp;quot;) %&amp;gt;%
  count(word1, sort = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table table-striped table-hover table-condensed table-responsive&#34; style=&#34;margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
word1
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
n
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
special
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
35
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
lorentz
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
4
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
newton’s
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
4
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
_special
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
comprehensive
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
electrodynamic
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
electromagnetic
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;In other analyses you may be interested in the most common trigrams, which are consecutive sequences of 3 words. We can find this by setting n = 3:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;trigram &amp;lt;- books %&amp;gt;%
  unnest_tokens(trigram, text, token = &amp;quot;ngrams&amp;quot;, n = 3) %&amp;gt;%
  separate(trigram, c(&amp;quot;word1&amp;quot;, &amp;quot;word2&amp;quot;, &amp;quot;word3&amp;quot;), sep = &amp;quot; &amp;quot;) %&amp;gt;%
  filter(!word1 %in% stop_words$word,
         !word2 %in% stop_words$word,
         !word3 %in% stop_words$word,  
         !is.na(word1)) %&amp;gt;%
  count(word1, word2, word3, sort = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table table-striped table-hover table-condensed table-responsive&#34; style=&#34;margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
word1
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
word2
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
word3
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
n
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
_x_1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
_x_2
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
_x_3
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
12
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
light
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
_in
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
vacuo_
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
10
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
reference
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
body
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
&lt;em&gt;k&lt;/em&gt;
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
10
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
space
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
time
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
continuum
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
9
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
_x_2
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
_x_3
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
_x_4
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
8
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
reference
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
body
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
_k
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
8
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
disruptive
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
discharge
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
coil
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
6
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div id=&#34;network-analysis&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.4&lt;/span&gt; Network analysis&lt;/h2&gt;
&lt;p&gt;We may be interested in visualizing all of the relationships among words simultaneously, rather than just the top few at a time. As one common visualization, we can arrange the words into a network, or “graph.” Here we’ll be referring to a “graph” not in the sense of a visualization, but as a combination of connected nodes. A graph can be constructed from a tidy object since it has three variables:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;from: the node an edge is coming from&lt;/li&gt;
&lt;li&gt;to: the node an edge is going towards&lt;/li&gt;
&lt;li&gt;weight: A numeric value associated with each edge&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;code&gt;igraph&lt;/code&gt; package has many functions for manipulating and analyzing networks. One way to create an igraph object from tidy data is the &lt;code&gt;graph_from_data_frame()&lt;/code&gt; function, which takes a data frame of edges with columns for “from”, “to”, and edge attributes (in this case n):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dplyr)
library(igraph)

# filter for only relatively common combinations
bigram_graph &amp;lt;- bigram_counts %&amp;gt;%
  filter(n &amp;gt; 5) %&amp;gt;%
  graph_from_data_frame()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We use the &lt;a href=&#34;https://cran.r-project.org/web/packages/ggraph/ggraph.pdf&#34;&gt;&lt;code&gt;ggraph&lt;/code&gt;&lt;/a&gt; package to convert the igraph object into a &lt;code&gt;ggraph&lt;/code&gt; with the ggraph function, after which we add layers to it, much like layers are added in ggplot2. For example, for a basic graph we need to add three layers: nodes, edges, and text:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggraph)
set.seed(123)

ggraph(bigram_graph, layout = &amp;quot;fr&amp;quot;) +
  geom_edge_link() +
  geom_node_point() +
  geom_node_text(aes(label = name), vjust = 1, hjust = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-09-16-r-text-mining/index_files/figure-html/unnamed-chunk-34-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Finally, we will change some settings to obtain to a better looking graph:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;We add the &lt;code&gt;edge_alpha&lt;/code&gt; aesthetic to the link layer to make links transparent based on how common or rare the bigram is.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We add directionality with an arrow, constructed using &lt;code&gt;grid::arrow()&lt;/code&gt;, including an &lt;code&gt;end_cap&lt;/code&gt; option that tells the arrow to end before touching the node.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We tinker with the options to the node layer to make the nodes more attractive (larger, blue points).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We add a theme that’s useful for plotting networks, &lt;code&gt;theme_void()&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggraph)
set.seed(123)

a &amp;lt;- grid::arrow(type = &amp;quot;closed&amp;quot;, length = unit(.15, &amp;quot;inches&amp;quot;))

ggraph(bigram_graph, layout = &amp;quot;fr&amp;quot;) +
  geom_edge_link(aes(edge_alpha = n), show.legend = FALSE,
                 arrow = a, end_cap = circle(.07, &amp;#39;inches&amp;#39;)) +
  geom_node_point(color = &amp;quot;lightblue&amp;quot;, size = 5) +
  geom_node_text(aes(label = name), vjust = 1, hjust = 1) +
  theme_void()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-09-16-r-text-mining/index_files/figure-html/unnamed-chunk-35-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;classification-with-logistic-regression&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;4&lt;/span&gt; Classification with logistic regression&lt;/h1&gt;
&lt;p&gt;In the first part we will build a statistical learning model. In the second part we will want to test it and assess its quality. Without dividing the dataset we would test the model on the data which the algorithm have already seen, which is why we start by splitting the data.&lt;/p&gt;
&lt;div id=&#34;train-test-split&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.1&lt;/span&gt; Train test split&lt;/h2&gt;
&lt;p&gt;Let’s go back to the original &lt;code&gt;books&lt;/code&gt; dataset (not the &lt;code&gt;tidy_books&lt;/code&gt; dataset) because the lines of text are our individual observations.&lt;/p&gt;
&lt;p&gt;We could use functions from the &lt;a href=&#34;https://tidymodels.github.io/rsample/&#34;&gt;&lt;code&gt;rsample&lt;/code&gt;&lt;/a&gt; package to generate resampled datasets, but the specific modeling approach we’re going to use will do that for us so we only need a simple train/test split.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(rsample)

books_split &amp;lt;- books %&amp;gt;%
  select(document) %&amp;gt;%
  initial_split(prop = 3/4)

train_data &amp;lt;- training(books_split)
test_data &amp;lt;- testing(books_split)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that we just select specific text rows (column &lt;code&gt;document&lt;/code&gt;) for training and others for our test data (we set the proportion of data to be retained for modeling/analysis to 3/4) without selecting the actual text lines at this point.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;training-data-sparse-matrix&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.2&lt;/span&gt; Training data (sparse matrix)&lt;/h2&gt;
&lt;p&gt;Now we want to transform our training data from a tidy data structure to a “sparse matrix” (these objects can be treated as though they were matrices, for example accessing particular rows and columns, but are stored in a more efficient format) to use for our classification algorithm.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidytext)

sparse_words &amp;lt;- tidy_books %&amp;gt;%
  count(document, word) %&amp;gt;%
  inner_join(train_data, by = &amp;quot;document&amp;quot;) %&amp;gt;%
  cast_sparse(document, word, n)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dim(sparse_words)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 4782  892&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have over 4,700 training observations and almost 900 features. Text feature space handled in this way is very high dimensional, so we need to take that into account when considering our modeling approach.&lt;/p&gt;
&lt;p&gt;One reason this overall approach is flexible is that you could at this point &lt;code&gt;cbind()&lt;/code&gt; other columns, such as non-text numeric data, onto this sparse matrix. Then you can use this combination of text and non-text data as your predictors in the classifiaction algorithm, and the regularized regression algorithm we are going to use will find which are important for your problem space.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;response-variable&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.3&lt;/span&gt; Response variable&lt;/h2&gt;
&lt;p&gt;We also need to build a tibble with a &lt;strong&gt;response variable&lt;/strong&gt; to associate each of the &lt;code&gt;rownames()&lt;/code&gt; of the sparse matrix with an author, to use as the quantity we will predict in the model.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;word_rownames &amp;lt;- as.integer(rownames(sparse_words))&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;books_joined &amp;lt;- tibble(document = word_rownames) %&amp;gt;%
  left_join(books  %&amp;gt;%
    select(document, author))&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table table-striped&#34; style=&#34;font-size: condensedpx; width: auto !important; margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
document
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
author
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
3
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
5
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
7
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
9
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
24
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
25
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Tesla, Nikola
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div id=&#34;logistic-regression-model&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.4&lt;/span&gt; Logistic regression model&lt;/h2&gt;
&lt;p&gt;Now it’s time to train our classification model. Let’s use the &lt;code&gt;glmnet&lt;/code&gt; package to fit a logistic regression model with &lt;em&gt;lasso&lt;/em&gt; (least absolute shrinkage and selection operator; also Lasso or LASSO) regularization. This regression analysis method performs both variable selection and regularization in order to enhance the prediction accuracy and interpretability of the statistical model it produces.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Glmnet&lt;/code&gt; is a package that fits lasso models via penalized maximum likelihood. We do not cover the method and glmnet package in detail at this point, but if you want to learn more about glmnet and lasso regression, review the following resources:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cran.r-project.org/web/packages/glmnet/vignettes/glmnet_beta.pdf&#34;&gt;Introduction to glmnet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cran.r-project.org/web/packages/glmnet/glmnet.pdf&#34;&gt;glmnet documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kirenz.com/post/2019-08-12-python-lasso-regression-auto/&#34;&gt;LASSO regression in Python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The package is very useful for text classification because the variable selection that lasso regularization performs can tell you which words are important for your prediction problem. The glmnet package also supports parallel processing, so we can train on multiple cores with &lt;a href=&#34;https://en.wikipedia.org/wiki/Cross-validation_(statistics)&#34;&gt;cross-validation&lt;/a&gt; on the training set using &lt;code&gt;cv.glmnet()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(glmnet)
library(doMC)
registerDoMC(cores = 8)

is_einstein &amp;lt;- books_joined$author == &amp;quot;Einstein, Albert&amp;quot;

model &amp;lt;- cv.glmnet(sparse_words, 
                   is_einstein,
                   family = &amp;quot;binomial&amp;quot;,
                   parallel = TRUE, 
                   keep = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s use the package &lt;a href=&#34;https://cran.r-project.org/web/packages/broom/vignettes/broom.html&#34;&gt;&lt;code&gt;broom&lt;/code&gt;&lt;/a&gt; (the broom package takes the messy output of built-in functions in R, such as lm, nls, or t.test, and turns them into tidy data frames) to check out the coefficients of the model, for the largest value of lambda with error within 1 standard error of the minimum (&lt;code&gt;lambda.1se&lt;/code&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(broom)

coefs &amp;lt;- model$glmnet.fit %&amp;gt;%
  tidy() %&amp;gt;%
  filter(lambda == model$lambda.1se)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which coefficents are the largest in size, in each direction:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(forcats)

coefs %&amp;gt;%
  group_by(estimate &amp;gt; 0) %&amp;gt;%
  top_n(10, abs(estimate)) %&amp;gt;%
  ungroup() %&amp;gt;%
  ggplot(aes(fct_reorder(term, estimate), estimate, fill = estimate &amp;gt; 0)) +
  geom_col(alpha = 0.8, show.legend = FALSE) +
  coord_flip() +
  labs(
    x = NULL,
    title = &amp;quot;Coefficients that increase/decrease probability the most&amp;quot;,
    subtitle = &amp;quot;A document mentioning lecture or probably is unlikely to be written by Albert Einstein&amp;quot;
  ) +
  theme_classic(base_size = 12) +
  theme(plot.title = element_text(lineheight=.8, face=&amp;quot;bold&amp;quot;)) +
  scale_fill_brewer()  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-09-16-r-text-mining/index_files/figure-html/unnamed-chunk-44-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;model-evaluation-with-test-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.5&lt;/span&gt; Model evaluation with test data&lt;/h2&gt;
&lt;p&gt;Now we want to evaluate how well this model is doing using the test data that we held out and did not use for training the model. Let’s create a dataframe that tells us, for each document in the test set, the probability of being written by Albert Einstein.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;intercept &amp;lt;- coefs %&amp;gt;%
  filter(term == &amp;quot;(Intercept)&amp;quot;) %&amp;gt;%
  pull(estimate)

classifications &amp;lt;- tidy_books %&amp;gt;%
  inner_join(test_data) %&amp;gt;%
  inner_join(coefs, by = c(&amp;quot;word&amp;quot; = &amp;quot;term&amp;quot;)) %&amp;gt;%
  group_by(document) %&amp;gt;%
  summarize(score = sum(estimate)) %&amp;gt;%
  mutate(probability = plogis(intercept + score))&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table table-striped&#34; style=&#34;font-size: condensedpx; width: auto !important; margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
document
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
score
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
probability
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
21
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
-1.3811800
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.2063129
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
26
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
-1.9929541
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.1235678
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
30
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
1.2522803
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.7834973
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
33
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
-1.8746267
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.1369635
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
52
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
-5.1987683
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0056813
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
54
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
-2.8148527
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0583613
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
56
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.2272565
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.5649167
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Now let’s use the &lt;a href=&#34;https://tidymodels.github.io/yardstick/&#34;&gt;&lt;code&gt;yardstick&lt;/code&gt;&lt;/a&gt; package (yardstick is a package to estimate how well models are working using tidy data principles) to calculate some model performance metrics. For example, what does the &lt;a href=&#34;https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc&#34;&gt;ROC curve&lt;/a&gt; (receiver operating characteristic curve - a graph showing the performance of a classification model at all classification thresholds) look like:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(yardstick)

comment_classes &amp;lt;- classifications %&amp;gt;%
  left_join(books %&amp;gt;%
    select(author, document), by = &amp;quot;document&amp;quot;) %&amp;gt;%
  mutate(author = as.factor(author))

comment_classes %&amp;gt;%
  roc_curve(author, probability) %&amp;gt;%
  ggplot(aes(x = 1 - specificity, y = sensitivity)) +
  geom_line(
    color = &amp;quot;midnightblue&amp;quot;,
    size = 1.5
  ) +
  geom_abline(
    lty = 2, alpha = 0.5,
    color = &amp;quot;gray50&amp;quot;,
    size = 1.2
  ) +
  labs(
    title = &amp;quot;ROC curve for text classification using regularized regression&amp;quot;,
    subtitle = &amp;quot;Predicting whether text was written by Albert Einstein or Nikola Tesla&amp;quot;
  ) +
  theme_classic(base_size = 12) +
  theme(plot.title = element_text(lineheight=.8, face=&amp;quot;bold&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-09-16-r-text-mining/index_files/figure-html/unnamed-chunk-47-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Let’s obtain the accuracy (AUC - the fraction of predictions that a classification model got right) on the test data:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;auc &amp;lt;- comment_classes %&amp;gt;%
  roc_auc(author, probability)&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table table-striped&#34; style=&#34;font-size: condensedpx; width: auto !important; margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
.metric
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
.estimator
&lt;/th&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
.estimate
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
roc_auc
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
binary
&lt;/td&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.9757987
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Next we turn to the &lt;strong&gt;confusion matrix&lt;/strong&gt;. Let’s make the following definitions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“Einstein, Albert” is a positive class.&lt;/li&gt;
&lt;li&gt;“Tesla, Nikola” is a negative class.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;&lt;span style=&#34;color:green&#34;&gt; &lt;strong&gt;True Positive (TP):&lt;/strong&gt; &lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span style=&#34;color:red&#34;&gt; &lt;strong&gt;False Positive (FP):&lt;/strong&gt; &lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;strong&gt;Reality&lt;/strong&gt;: Text is from Einstein&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Reality&lt;/strong&gt;: Text is from Tesla&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;strong&gt;Model&lt;/strong&gt;: Text is from Einstein&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Model&lt;/strong&gt;: Text is from Einstein&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;&lt;span style=&#34;color:red&#34;&gt; &lt;strong&gt;False Negative (FN):&lt;/strong&gt; &lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span style=&#34;color:green&#34;&gt; &lt;strong&gt;True Negative (TN):&lt;/strong&gt; &lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;strong&gt;Reality&lt;/strong&gt;: Text is from Einstein&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Reality&lt;/strong&gt;: Text is from Tesla&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;strong&gt;Model&lt;/strong&gt;: Text is from Tesla&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Model&lt;/strong&gt;: Text is from Tesla&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;We can summarize our “einstein-text-prediction” model using a 2x2 confusion matrix that depicts all four possible outcomes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A &lt;em&gt;true positive&lt;/em&gt; is an outcome where the model correctly predicts the positive class (Einstein). Similarly, a &lt;em&gt;true negative&lt;/em&gt; is an outcome where the model correctly predicts the negative class (Tesla).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A &lt;em&gt;false positive&lt;/em&gt; is an outcome where the model incorrectly predicts the positive class. And a &lt;em&gt;false negative&lt;/em&gt; is an outcome where the model incorrectly predicts the negative class.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let’s use a probability of 0.5 as our threshold. That means all model predictions with a probability greater than 50% get labeld as beeing text from Einstein:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;comment_classes %&amp;gt;%
  mutate(prediction = case_when(
          probability &amp;gt; 0.5 ~ &amp;quot;Einstein, Albert&amp;quot;,
          TRUE ~ &amp;quot;Tesla, Nikola&amp;quot;),
        prediction = as.factor(prediction)) %&amp;gt;%
  conf_mat(author, prediction)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                   Truth
## Prediction         Einstein, Albert Tesla, Nikola
##   Einstein, Albert              628            58
##   Tesla, Nikola                  70           784&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s take a closer look at these misclassifications: false negatives (FN) and false positives (FP). Which documents here were incorrectly predicted to be written by Albert Einstein, at the extreme probability end of greater than 80% (false positive)?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;FP&amp;lt;- comment_classes %&amp;gt;%
  filter(probability &amp;gt; .8,
          author == &amp;quot;Tesla, Nikola&amp;quot;) %&amp;gt;%
  sample_n(10) %&amp;gt;%
  inner_join(books %&amp;gt;%
  select(document, text)) %&amp;gt;%
  select(probability, text)&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table table-striped&#34; style=&#34;font-size: condensedpx; width: auto !important; margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
probability
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
text
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.8189629
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
through things. He is an omnivorous reader, who never forgets; and he
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.9012553
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
our sense of vision.
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.8094770
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
enormous distance without affecting greatly the character of the
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.9058630
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
experience of to-day enables us to see clearly why these coils under
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.8509898
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
discharger I have been able to maintain an oscillating motion without
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.8119290
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
little thought leads us to the conclusion that, could we but reach
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.9086652
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
disc, which could be seen from a considerable distance, such is the
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.9440000
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
obtainable at any point of the universe. This idea is not novel. Men
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.9069282
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
Leaving practicability out of consideration, this, then, would be the
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.8595897
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
plant, and on returning to Paris sought to carry out a number of ideas
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;These documents were incorrectly predicted to be written by Albert Einstein. However, they were written by Nikola Tesla.&lt;/p&gt;
&lt;p&gt;Finally, let’s take a look at the texts which are from Albert Einstein that the model did not correctly identify (false negative):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;FN &amp;lt;- comment_classes %&amp;gt;%
  filter(probability &amp;lt; .3,
         author == &amp;quot;Einstein, Albert&amp;quot;) %&amp;gt;%
  sample_n(10) %&amp;gt;%
  inner_join(books %&amp;gt;%
  select(document, text)) %&amp;gt;%
  select(probability, text)&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table table-striped&#34; style=&#34;font-size: condensedpx; width: auto !important; margin-left: auto; margin-right: auto;&#34;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:right;&#34;&gt;
probability
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
text
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0969140
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
be arbitrary, although it was always tacitly made even before the
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.1989692
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
strings to the floor, otherwise the slightest impact against the floor
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.1994746
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
local variations of temperature, and with which we made acquaintance as
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.1932809
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
the conservation of energy (and of impulse).
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0546119
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
me—and rightly so—and you declare: “I maintain my previous definition
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0613870
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
permits of our answering it with a moderate degree of certainty, and in
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.2458622
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
treated in detail and with unsurpassable lucidity by Helmholtz and
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.1886392
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
gravitational potential, then the study of this displacement will
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.1570832
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
for the following reason. As a result of the more careful study of
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right;&#34;&gt;
0.0134175
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
throwing it. Then, disregarding the influence of the air resistance, I
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;We can conclude that the model did a very good job in predicting the authors of the texts. Furthermore, the texts of the misclassifications are quite short and we can imagine, that even a human reader who is familiar with the work of Einstein and Tesla would have difficulties to classify them correctly.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Social Network Analysis with Python</title>
      <link>/post/2019-08-13-network_analysis/</link>
      <pubDate>Thu, 15 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-08-13-network_analysis/</guid>
      <description>

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#social-network-analysis-with-networkx-in-python&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1&lt;/span&gt; Social Network Analysis with NetworkX in Python&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#social-network-basics&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.1&lt;/span&gt; Social Network Basics&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#symmetric-networks-undirected&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.1.1&lt;/span&gt; Symmetric Networks (undirected)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#asymmetric-networks-directed&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.1.2&lt;/span&gt; Asymmetric Networks (directed)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#weighted-networks&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.1.3&lt;/span&gt; Weighted Networks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#clustering-coefficient&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.2&lt;/span&gt; Clustering coefficient&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#network-distance-measures&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.3&lt;/span&gt; Network Distance Measures&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#degree&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.3.1&lt;/span&gt; Degree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#distance&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.3.2&lt;/span&gt; Distance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#breadth-first-search&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.3.3&lt;/span&gt; Breadth-first search&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#eccentricity&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.3.4&lt;/span&gt; Eccentricity&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#centrality-measures&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.4&lt;/span&gt; Centrality measures&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#degree-centrality&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.4.1&lt;/span&gt; Degree Centrality&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#eigenvector-centrality&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.4.2&lt;/span&gt; Eigenvector Centrality&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#closeness-centrality&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.4.3&lt;/span&gt; Closeness Centrality&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#betweenness-centrality&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.4.4&lt;/span&gt; Betweenness Centrality&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#facebook-case-study&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.5&lt;/span&gt; Facebook Case Study&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;social-network-analysis-with-networkx-in-python&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;1&lt;/span&gt; Social Network Analysis with NetworkX in Python&lt;/h1&gt;
&lt;p&gt;We use the module &lt;a href=&#34;https://networkx.github.io/documentation/stable/&#34;&gt;NetworkX&lt;/a&gt; in this tutorial. It is a Python package for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks.&lt;/p&gt;
&lt;p&gt;If you work with &lt;a href=&#34;https://www.anaconda.com/distribution/&#34;&gt;Anaconda&lt;/a&gt;, you can install the package as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conda install -c anaconda networkx&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Import modules:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import networkx as nx
import matplotlib.pyplot as plt
%matplotlib inline
import warnings; warnings.simplefilter(&amp;#39;ignore&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;div id=&#34;social-network-basics&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.1&lt;/span&gt; Social Network Basics&lt;/h2&gt;
&lt;p&gt;Each network consists of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nodes: The individuals whose network we are building.&lt;/li&gt;
&lt;li&gt;Edges: The connection between the nodes. It represents a relationship between the nodes of the network.&lt;/li&gt;
&lt;/ul&gt;
&lt;div id=&#34;symmetric-networks-undirected&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.1.1&lt;/span&gt; Symmetric Networks (undirected)&lt;/h3&gt;
&lt;p&gt;The first network that we create is a group of people who work together. This is called a &lt;strong&gt;symmetric network&lt;/strong&gt; because the relationship “working together” is a symmetric relationship: If A is related to B, B is also related to A.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;G_symmetric = nx.Graph()

G_symmetric.add_edge(&amp;#39;Steven&amp;#39;,  &amp;#39;Laura&amp;#39;)
G_symmetric.add_edge(&amp;#39;Steven&amp;#39;,  &amp;#39;Marc&amp;#39;)
G_symmetric.add_edge(&amp;#39;Steven&amp;#39;,  &amp;#39;John&amp;#39;)
G_symmetric.add_edge(&amp;#39;Steven&amp;#39;,  &amp;#39;Michelle&amp;#39;)
G_symmetric.add_edge(&amp;#39;Laura&amp;#39;,   &amp;#39;Michelle&amp;#39;)
G_symmetric.add_edge(&amp;#39;Michelle&amp;#39;,&amp;#39;Marc&amp;#39;)
G_symmetric.add_edge(&amp;#39;George&amp;#39;,  &amp;#39;John&amp;#39;)
G_symmetric.add_edge(&amp;#39;George&amp;#39;,  &amp;#39;Steven&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(nx.info(G_symmetric))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Name:
Type: Graph
Number of nodes: 6
Number of edges: 8
Average degree:   2.6667&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we visualize the network with the &lt;code&gt;draw_networkx()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;plt.figure(figsize=(5,5))
nx.draw_networkx(G_symmetric);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-13-network_analysis/output_8_0.png&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;asymmetric-networks-directed&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.1.2&lt;/span&gt; Asymmetric Networks (directed)&lt;/h3&gt;
&lt;p&gt;What if the relationship between nodes is ‘child of’, then the relationship is no longer symmetric. This is the case if someone follows someone else on Twitter. Or in the case of hyperlinks.&lt;/p&gt;
&lt;p&gt;If A is the child of B, then B is not a child of A. Such a network where the relationship is &lt;strong&gt;asymmetric&lt;/strong&gt; (A is related to B, does not necessarily means that B is associated with A) is called an Asymmetric network.&lt;/p&gt;
&lt;p&gt;We can build the asymmetric network in NetworkX using &lt;code&gt;DiGraph&lt;/code&gt; method, which is short of &lt;strong&gt;Directional Graph&lt;/strong&gt;.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;G_asymmetric = nx.DiGraph()
G_asymmetric.add_edge(&amp;#39;A&amp;#39;,&amp;#39;B&amp;#39;)
G_asymmetric.add_edge(&amp;#39;A&amp;#39;,&amp;#39;D&amp;#39;)
G_asymmetric.add_edge(&amp;#39;C&amp;#39;,&amp;#39;A&amp;#39;)
G_asymmetric.add_edge(&amp;#39;D&amp;#39;,&amp;#39;E&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To make sure that all nodes are distinctly visible in the network, use the &lt;code&gt;spring_layout()&lt;/code&gt; function, followed by the &lt;code&gt;draw_networkx()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;nx.spring_layout(G_asymmetric)
nx.draw_networkx(G_asymmetric)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-13-network_analysis/output_12_0.png&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;weighted-networks&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.1.3&lt;/span&gt; Weighted Networks&lt;/h3&gt;
&lt;p&gt;Till now we had networks without weights, but it is possible that networks are made with weights, for example, if in our initial network we consider the number of projects done together as a weight, we will get a weighted Network.&lt;/p&gt;
&lt;p&gt;Let us make one again of the employees, but this time we add weight to the network, each edge has a weight signifying the number of projects they have done together.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;G_weighted = nx.Graph()

G_weighted.add_edge(&amp;#39;Steven&amp;#39;,  &amp;#39;Laura&amp;#39;,   weight=25)
G_weighted.add_edge(&amp;#39;Steven&amp;#39;,  &amp;#39;Marc&amp;#39;,    weight=8)
G_weighted.add_edge(&amp;#39;Steven&amp;#39;,  &amp;#39;John&amp;#39;,    weight=11)
G_weighted.add_edge(&amp;#39;Steven&amp;#39;,  &amp;#39;Michelle&amp;#39;,weight=1)
G_weighted.add_edge(&amp;#39;Laura&amp;#39;,   &amp;#39;Michelle&amp;#39;,weight=1)
G_weighted.add_edge(&amp;#39;Michelle&amp;#39;,&amp;#39;Marc&amp;#39;,    weight=1)
G_weighted.add_edge(&amp;#39;George&amp;#39;,  &amp;#39;John&amp;#39;,    weight=8)
G_weighted.add_edge(&amp;#39;George&amp;#39;,  &amp;#39;Steven&amp;#39;,  weight=4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;elarge = [(u, v) for (u, v, d) in G_weighted.edges(data=True) if d[&amp;#39;weight&amp;#39;] &amp;gt; 8]
esmall = [(u, v) for (u, v, d) in G_weighted.edges(data=True) if d[&amp;#39;weight&amp;#39;] &amp;lt;= 8]

pos = nx.circular_layout(G_weighted)  # positions for all nodes

# nodes
nx.draw_networkx_nodes(G_weighted, pos, node_size=700)

# edges
nx.draw_networkx_edges(G_weighted, pos, edgelist=elarge,width=6)
nx.draw_networkx_edges(G_weighted, pos, edgelist=esmall,width=6, alpha=0.5, edge_color=&amp;#39;b&amp;#39;, style=&amp;#39;dashed&amp;#39;)

# labels
nx.draw_networkx_labels(G_weighted, pos, font_size=20, font_family=&amp;#39;sans-serif&amp;#39;)

plt.axis(&amp;#39;off&amp;#39;)
plt.show();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-13-network_analysis/output_15_0.png&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;clustering-coefficient&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.2&lt;/span&gt; Clustering coefficient&lt;/h2&gt;
&lt;p&gt;It is observed that people who share connections in a social network tend to form associations. In other words, there is a tendency in a social network to form clusters.&lt;/p&gt;
&lt;p&gt;We can determine the clusters of a node, &lt;strong&gt;local clustering coefficient&lt;/strong&gt;, which is the fraction of pairs of the node’s friends (that is connections) that are connected with each other.&lt;/p&gt;
&lt;p&gt;To determine the local clustering coefficient, we make use of &lt;code&gt;nx.clustering(Graph, Node)&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;In the symmetric employee-network, you will find that Michelle has a local clustering coefficient of 0.67 and Laura has a local clustering coefficient of 1.&lt;/p&gt;
&lt;p&gt;The average clustering coefficient (sum of all the local clustering coefficients divided by the number of nodes) for the symmetric employee-network is 0.867.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;nx.clustering(G_symmetric,&amp;#39;Michelle&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0.6666666666666666&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;nx.clustering(G_symmetric,&amp;#39;Laura&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1.0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;nx.average_clustering(G_symmetric)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0.8277777777777778&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;network-distance-measures&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.3&lt;/span&gt; Network Distance Measures&lt;/h2&gt;
&lt;div id=&#34;degree&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.3.1&lt;/span&gt; Degree&lt;/h3&gt;
&lt;p&gt;Degree of a node defines the number of connections a node has. NetworkX has the function &lt;code&gt;degree&lt;/code&gt; which we can use to determine the degree of a node in the network.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;nx.degree(G_symmetric, &amp;#39;Michelle&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will return a value of 3, as Michelle has worked with three employees in the network.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;distance&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.3.2&lt;/span&gt; Distance&lt;/h3&gt;
&lt;p&gt;We can also determine the shortest path between two nodes and its length in NetworkX using &lt;code&gt;nx.shortest_path(Graph, Node1, Node2)&lt;/code&gt; and &lt;code&gt;nx.shortest_path_length(Graph, Node1, Node2)&lt;/code&gt;
functions respectively.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;nx.shortest_path(G_symmetric, &amp;#39;Michelle&amp;#39;, &amp;#39;John&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[&amp;#39;Michelle&amp;#39;, &amp;#39;Steven&amp;#39;, &amp;#39;John&amp;#39;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;nx.shortest_path_length(G_symmetric, &amp;#39;Michelle&amp;#39;, &amp;#39;John&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;breadth-first-search&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.3.3&lt;/span&gt; Breadth-first search&lt;/h3&gt;
&lt;p&gt;We can find the distance of a node from every other node in the network using breadth-first search algorithm, starting from that node. networkX provides the function bfs_tree to do it.&lt;/p&gt;
&lt;p&gt;And so if you use &lt;code&gt;M = nx.bfs_tree(G_symmetric, &#39;Michelle&#39;)&lt;/code&gt; and now draw this tree, we will get a network structure telling how we can reach other nodes of the network starting from Michelle .&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;S = nx.bfs_tree(G_symmetric, &amp;#39;Steven&amp;#39;)
nx.draw_networkx(S)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-13-network_analysis/output_29_0.png&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;M = nx.bfs_tree(G_symmetric, &amp;#39;Michelle&amp;#39;)
nx.draw_networkx(M)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-13-network_analysis/output_30_0.png&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;eccentricity&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.3.4&lt;/span&gt; Eccentricity&lt;/h3&gt;
&lt;p&gt;Eccentricity of a node A is defined as the largest distance between A and all other nodes.&lt;/p&gt;
&lt;p&gt;It can be found using &lt;code&gt;nx.eccentricity()&lt;/code&gt; function. In the symmetric employee-network, Michelle has an eccentricity of 2, and Steven has an eccentricity of 1 (he is connected to every other node).&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;nx.eccentricity(G_symmetric,&amp;#39;Michelle&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;nx.eccentricity(G_symmetric,&amp;#39;Steven&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;centrality-measures&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.4&lt;/span&gt; Centrality measures&lt;/h2&gt;
&lt;p&gt;Above we learned some of the network distance measures and they are useful in knowing how the information will spread through the network.&lt;/p&gt;
&lt;p&gt;In this section, we will learn how to find the most important nodes (individuals) in the network. These parameters are called as &lt;strong&gt;centrality measures&lt;/strong&gt;. Centrality Measures can help us in identifying popularity, most liked, and biggest influencers within the network.&lt;/p&gt;
&lt;div id=&#34;degree-centrality&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.4.1&lt;/span&gt; Degree Centrality&lt;/h3&gt;
&lt;p&gt;The people most popular or more liked usually are the ones who have more friends.&lt;/p&gt;
&lt;p&gt;Degree centrality is a measure of the number of connections a particular node has in the network. It is based on the fact that important nodes have many connections. NetworkX has the function &lt;code&gt;degree_centrality()&lt;/code&gt; to calculate the degree centrality of all the nodes of a network.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;nx.degree_centrality(G_symmetric)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{&amp;#39;Steven&amp;#39;: 1.0,
 &amp;#39;Laura&amp;#39;: 0.4,
 &amp;#39;Marc&amp;#39;: 0.4,
 &amp;#39;John&amp;#39;: 0.4,
 &amp;#39;Michelle&amp;#39;: 0.6000000000000001,
 &amp;#39;George&amp;#39;: 0.4}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;eigenvector-centrality&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.4.2&lt;/span&gt; Eigenvector Centrality&lt;/h3&gt;
&lt;p&gt;It is not just how many individuals one is connected too, but the type of people one is connected with that can decide the importance of a node.&lt;/p&gt;
&lt;p&gt;Eigenvector centrality is a measure of how import a node is by accounting for the fact of how well it is connected to other important nodes.&lt;/p&gt;
&lt;p&gt;We can use the &lt;code&gt;eigenvector_centrality()&lt;/code&gt; function of NetworkX to calculate eigenvector centrality of all the nodes in a network.&lt;/p&gt;
&lt;p&gt;The Google’s Pagerank algorithm is a variant of Eigenvector centrality algorithm.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;nx.eigenvector_centrality(G_symmetric)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{&amp;#39;Steven&amp;#39;: 0.6006686104947806,
 &amp;#39;Laura&amp;#39;: 0.3545677660798074,
 &amp;#39;Marc&amp;#39;: 0.3545677660798074,
 &amp;#39;John&amp;#39;: 0.30844592433424667,
 &amp;#39;Michelle&amp;#39;: 0.4443904166426225,
 &amp;#39;George&amp;#39;: 0.30844592433424667}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;closeness-centrality&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.4.3&lt;/span&gt; Closeness Centrality&lt;/h3&gt;
&lt;p&gt;Closeness Centrality is a measure where each node’s importance is determined by &lt;strong&gt;closeness to all other nodes&lt;/strong&gt;.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;nx.closeness_centrality(G_symmetric)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{&amp;#39;Steven&amp;#39;: 1.0,
 &amp;#39;Laura&amp;#39;: 0.625,
 &amp;#39;Marc&amp;#39;: 0.625,
 &amp;#39;John&amp;#39;: 0.625,
 &amp;#39;Michelle&amp;#39;: 0.7142857142857143,
 &amp;#39;George&amp;#39;: 0.625}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;betweenness-centrality&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.4.4&lt;/span&gt; Betweenness Centrality&lt;/h3&gt;
&lt;p&gt;The Betweenness Centrality is the centrality of control.&lt;/p&gt;
&lt;p&gt;It represents the frequency at which a point occurs on the &lt;strong&gt;shortest paths&lt;/strong&gt; that connected pair of points. It quantifies how many times a particular node comes in the shortest chosen path between two other nodes.&lt;/p&gt;
&lt;p&gt;The nodes with high betweenness centrality play a significant role in the communication/information flow within the network.&lt;/p&gt;
&lt;p&gt;The nodes with high betweenness centrality can have a strategic control and influence on others. An individual at such a strategic position can influence the whole group, by either withholding or coloring the information in transmission.&lt;/p&gt;
&lt;p&gt;Networkx has the function &lt;code&gt;betweenness_centrality()&lt;/code&gt; to measure it for the network. It has options to select if we want betweenness values to be normalized or not, weights to be included in centrality calculation or not, and to include the endpoints in the shortest path counts or not.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;nx.betweenness_centrality(G_symmetric)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{&amp;#39;Steven&amp;#39;: 0.65,
 &amp;#39;Laura&amp;#39;: 0.0,
 &amp;#39;Marc&amp;#39;: 0.0,
 &amp;#39;John&amp;#39;: 0.0,
 &amp;#39;Michelle&amp;#39;: 0.05,
 &amp;#39;George&amp;#39;: 0.0}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;pos = nx.spring_layout(G_symmetric)
betCent = nx.betweenness_centrality(G_symmetric, normalized=True, endpoints=True)
node_color = [20000.0 * G_symmetric.degree(v) for v in G_symmetric]
node_size =  [v * 10000 for v in betCent.values()]
plt.figure(figsize=(10,10))
nx.draw_networkx(G_symmetric, pos=pos, with_labels=True,
                 node_color=node_color,
                 node_size=node_size )
plt.axis(&amp;#39;off&amp;#39;);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-13-network_analysis/output_45_0.png&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;sorted(betCent, key=betCent.get, reverse=True)[:5]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[&amp;#39;Steven&amp;#39;, &amp;#39;Michelle&amp;#39;, &amp;#39;Laura&amp;#39;, &amp;#39;Marc&amp;#39;, &amp;#39;John&amp;#39;]&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;facebook-case-study&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.5&lt;/span&gt; Facebook Case Study&lt;/h2&gt;
&lt;p&gt;This dataset consists of ‘circles’ (or ‘friends lists’) from Facebook. Facebook data was collected from survey participants using this Facebook app. The dataset includes node features (profiles), circles, and ego networks.&lt;/p&gt;
&lt;p&gt;Facebook data has been anonymized by replacing the Facebook-internal ids for each user with a new value. Also, while feature vectors from this dataset have been provided, the interpretation of those features has been obscured. For instance, where the original dataset may have contained a feature “political=Democratic Party”, the new data would simply contain “political=anonymized feature 1”. Thus, using the anonymized data it is possible to determine whether two users have the same political affiliations, but not what their individual political affiliations represent.&lt;/p&gt;
&lt;p&gt;Source: &lt;a href=&#34;https://snap.stanford.edu/data/egonets-Facebook.html&#34;&gt;J. McAuley and J. Leskovec. Learning to Discover Social Circles in Ego Networks. NIPS, 2012&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Let us start with the Facebook data, for our analysis here we will use Facebook combined ego networks dataset, it contains the aggregated network of ten individuals’ Facebook friends list. You can download the required facebook_combined.txt file from the Stanford University site.&lt;/p&gt;
&lt;p&gt;We read in the file and construct the Graph:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.dropbox.com/s/k34phmodh9nsy9r/facebook_combined.txt?dl=0&#34;&gt;Download the file&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import pandas as pd

df = pd.read_csv(&amp;#39;/Users/jankirenz/Dropbox/Data/facebook_combined.txt&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df.info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;class &amp;#39;pandas.core.frame.DataFrame&amp;#39;&amp;gt;
RangeIndex: 88233 entries, 0 to 88232
Data columns (total 1 columns):
0 1    88233 non-null object
dtypes: object(1)
memory usage: 689.4+ KB&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df.tail()&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
&lt;thead&gt;
&lt;tr style=&#34;text-align: right;&#34;&gt;
&lt;th&gt;
&lt;/th&gt;
&lt;th&gt;
0 1
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
88228
&lt;/th&gt;
&lt;td&gt;
4026 4030
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
88229
&lt;/th&gt;
&lt;td&gt;
4027 4031
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
88230
&lt;/th&gt;
&lt;td&gt;
4027 4032
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
88231
&lt;/th&gt;
&lt;td&gt;
4027 4038
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
88232
&lt;/th&gt;
&lt;td&gt;
4031 4038
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;G_fb = nx.read_edgelist(&amp;quot;/Users/jankirenz/Dropbox/Data/facebook_combined.txt&amp;quot;, create_using = nx.Graph(), nodetype=int)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(nx.info(G_fb))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Name:
Type: Graph
Number of nodes: 4039
Number of edges: 88234
Average degree: 43.6910&lt;/p&gt;
&lt;p&gt;The network consists of 4,039 nodes, connected via 88,234 edges.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;plt.figure(figsize=(20,20))
nx.draw_networkx(G_fb);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-13-network_analysis/net1.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We can also visualize the network such that the node color varies with Degree and node size with Betweenness Centrality. The code to do this is:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;pos = nx.spring_layout(G_fb)
betCent = nx.betweenness_centrality(G_fb, normalized=True, endpoints=True)
node_color = [20000.0 * G_fb.degree(v) for v in G_fb]
node_size =  [v * 10000 for v in betCent.values()]
plt.figure(figsize=(20,20))
nx.draw_networkx(G_fb, pos=pos, with_labels=False,
                 node_color=node_color,
                 node_size=node_size )
plt.axis(&amp;#39;off&amp;#39;);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-13-network_analysis/net2.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;You can also know the labels of the nodes with the highest betweenness centrality using:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;sorted(betCent, key=betCent.get, reverse=True)[:5]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see that some nodes are common between Degree Centrality, which is a measure of degree, and Betweenness Centrality which controls the information flow.&lt;/p&gt;
&lt;p&gt;It is natural that nodes that are more connected also lie on shortest paths between other nodes. The node 1912 is an important node as it is crucial according to all three centrality measures that we had considered.&lt;/p&gt;
&lt;hr /&gt;
&lt;hr /&gt;
&lt;p&gt;Sources of examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.datacamp.com/community/tutorials/social-network-analysis-python&#34;&gt;Datacamp&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aksakalli.github.io/2017/07/17/network-centrality-measures-and-their-visualization.html&#34;&gt;Aksakalli, C.&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://snap.stanford.edu/data/egonets-Facebook.html&#34;&gt;McAuley, J. &amp;amp; Leskovec, J.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Lasso Regression with Python</title>
      <link>/post/2019-08-12-python-lasso-regression-auto/</link>
      <pubDate>Mon, 12 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-08-12-python-lasso-regression-auto/</guid>
      <description>

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#lasso-regression-basics&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1&lt;/span&gt; Lasso Regression Basics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#implementation-of-lasso-regression&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2&lt;/span&gt; Implementation of Lasso regression&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#standardization&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.1&lt;/span&gt; Standardization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#split-data&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.2&lt;/span&gt; Split data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lasso-regression&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.3&lt;/span&gt; Lasso regression&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lasso-with-different-lambdas&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.4&lt;/span&gt; Lasso with different lambdas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#plot-values-as-a-function-of-lambda&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.5&lt;/span&gt; Plot values as a function of lambda&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#identify-best-lambda-and-coefficients&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.6&lt;/span&gt; Identify best lambda and coefficients&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cross-validation&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.7&lt;/span&gt; Cross Validation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#best-model&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.8&lt;/span&gt; Best Model&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;lasso-regression-basics&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;1&lt;/span&gt; Lasso Regression Basics&lt;/h1&gt;
&lt;p&gt;Lasso performs a so called &lt;code&gt;L1 regularization&lt;/code&gt; (a process of introducing additional information in order to prevent overfitting), i.e. adds penalty equivalent to absolute value of the magnitude of coefficients.&lt;/p&gt;
&lt;p&gt;In particular, the minimization objective does not only include the residual sum of squares (RSS) - like in the OLS regression setting - but also the sum of the absolute value of coefficients.&lt;/p&gt;
&lt;p&gt;The residual sum of squares (RSS) is calculated as follows:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ RSS = \sum_{i=1}^{n} (y_i - \hat{y_i})^2 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;This formula can be stated as:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ RSS = \sum_{i=1}^{n} \bigg(y_i - \big( \beta_{0} + \sum_{j=1}^{p} \beta_{j} x_{ij} \big) \bigg)^2  \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n represents the number of distinct data points, or observations, in our sample.&lt;/li&gt;
&lt;li&gt;p denotes the number of variables that are available in the dataset.&lt;/li&gt;
&lt;li&gt;x_{ij} represents the value of the jth variable for the ith observation, where i = 1, 2, . . ., n and j = 1, 2, . . . , p.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the lasso regression, the minimization objective becomes:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ \sum_{i=1}^{n} \bigg(y_i - \big( \beta_{0} + \sum_{j=1}^{p} \beta_{j} x_{ij} \big) \bigg)^2 + \lambda \sum_{j=1}^{p} |\beta_j|   \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;which equals:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[RSS + \lambda \sum_{j=1}^{p} |\beta_j|  \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\lambda\)&lt;/span&gt; (lambda) provides a trade-off between balancing RSS and magnitude of coefficients.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\lambda\)&lt;/span&gt; can take various values:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(\lambda\)&lt;/span&gt; = 0: Same coefficients as simple linear regression&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(\lambda\)&lt;/span&gt; = ∞: All coefficients zero (same logic as before)&lt;/li&gt;
&lt;li&gt;0 &amp;lt; &lt;span class=&#34;math inline&#34;&gt;\(\lambda\)&lt;/span&gt; &amp;lt; ∞: coefficients between 0 and that of simple linear regression&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;div id=&#34;implementation-of-lasso-regression&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;2&lt;/span&gt; Implementation of Lasso regression&lt;/h1&gt;
&lt;p&gt;Python set up:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
%matplotlib inline
plt.style.use(&amp;#39;ggplot&amp;#39;)
import warnings; warnings.simplefilter(&amp;#39;ignore&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This notebook involves the use of the Lasso regression on the “Auto” dataset. In particular, we only use observations 1 to 200 for our analysis. Furthermore, you can drop the &lt;code&gt;name&lt;/code&gt; variable.&lt;/p&gt;
&lt;p&gt;Import data:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df = pd.read_csv(&amp;quot;https://raw.githubusercontent.com/kirenz/datasets/master/Auto.csv&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tidying data:&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df = df.iloc[0:200]
df = df.drop([&amp;#39;name&amp;#39;], axis=1)
df.info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;class &amp;#39;pandas.core.frame.DataFrame&amp;#39;&amp;gt;
RangeIndex: 200 entries, 0 to 199
Data columns (total 8 columns):
mpg             200 non-null float64
cylinders       200 non-null int64
displacement    200 non-null float64
horsepower      200 non-null object
weight          200 non-null int64
acceleration    200 non-null float64
year            200 non-null int64
origin          200 non-null int64
dtypes: float64(3), int64(4), object(1)
memory usage: 12.6+ KB&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df[&amp;#39;origin&amp;#39;] = pd.Categorical(df[&amp;#39;origin&amp;#39;])
df[&amp;#39;horsepower&amp;#39;] = pd.to_numeric(df[&amp;#39;horsepower&amp;#39;], errors=&amp;#39;coerce&amp;#39;)
print(df.isnull().sum())&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mpg             0
cylinders       0
displacement    0
horsepower      2
weight          0
acceleration    0
year            0
origin          0
dtype: int64&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# drop missing cases
df = df.dropna()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We use scikit learn to fit a Lasso regression &lt;a href=&#34;http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Lasso.html&#34;&gt;(see documentation)&lt;/a&gt; and follow a number of steps (note that scikit-learn uses &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt; instead of &lt;span class=&#34;math inline&#34;&gt;\(\lambda\)&lt;/span&gt; in their notation):&lt;/p&gt;
&lt;div id=&#34;standardization&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.1&lt;/span&gt; Standardization&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Standardize the features with the module: &lt;code&gt;from sklearn.preprocessing import StandardScaler&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;It is important to standardize the features by removing the mean and scaling to unit variance. The L1 (Lasso) and L2 (Ridge) regularizers of linear models assume that all features are centered around 0 and have variance in the same order. If a feature has a variance that is orders of magnitude larger that others, it might dominate the objective function and make the estimator unable to learn from other features correctly as expected.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;dfs = df.astype(&amp;#39;int&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;dfs.info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;class &amp;#39;pandas.core.frame.DataFrame&amp;#39;&amp;gt;
Int64Index: 198 entries, 0 to 199
Data columns (total 8 columns):
mpg             198 non-null int64
cylinders       198 non-null int64
displacement    198 non-null int64
horsepower      198 non-null int64
weight          198 non-null int64
acceleration    198 non-null int64
year            198 non-null int64
origin          198 non-null int64
dtypes: int64(8)
memory usage: 13.9 KB&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;dfs.columns&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Index([&amp;#39;mpg&amp;#39;, &amp;#39;cylinders&amp;#39;, &amp;#39;displacement&amp;#39;, &amp;#39;horsepower&amp;#39;, &amp;#39;weight&amp;#39;,
       &amp;#39;acceleration&amp;#39;, &amp;#39;year&amp;#39;, &amp;#39;origin&amp;#39;],
      dtype=&amp;#39;object&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
dfs[[&amp;#39;cylinders&amp;#39;, &amp;#39;displacement&amp;#39;, &amp;#39;horsepower&amp;#39;,
     &amp;#39;weight&amp;#39;, &amp;#39;acceleration&amp;#39;, &amp;#39;year&amp;#39;, &amp;#39;origin&amp;#39;]] = scaler.fit_transform(dfs[[&amp;#39;cylinders&amp;#39;,
                                                                              &amp;#39;displacement&amp;#39;,
                                                                              &amp;#39;horsepower&amp;#39;,
                                                                              &amp;#39;weight&amp;#39;,
                                                                              &amp;#39;acceleration&amp;#39;,
                                                                              &amp;#39;year&amp;#39;, &amp;#39;origin&amp;#39;]])&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;dfs.head(5)&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
&lt;thead&gt;
&lt;tr style=&#34;text-align: right;&#34;&gt;
&lt;th&gt;
&lt;/th&gt;
&lt;th&gt;
mpg
&lt;/th&gt;
&lt;th&gt;
cylinders
&lt;/th&gt;
&lt;th&gt;
displacement
&lt;/th&gt;
&lt;th&gt;
horsepower
&lt;/th&gt;
&lt;th&gt;
weight
&lt;/th&gt;
&lt;th&gt;
acceleration
&lt;/th&gt;
&lt;th&gt;
year
&lt;/th&gt;
&lt;th&gt;
origin
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;
0
&lt;/th&gt;
&lt;td&gt;
18
&lt;/td&gt;
&lt;td&gt;
1.179744
&lt;/td&gt;
&lt;td&gt;
0.726091
&lt;/td&gt;
&lt;td&gt;
0.325216
&lt;/td&gt;
&lt;td&gt;
0.346138
&lt;/td&gt;
&lt;td&gt;
-0.955578
&lt;/td&gt;
&lt;td&gt;
-1.516818
&lt;/td&gt;
&lt;td&gt;
-0.629372
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
1
&lt;/th&gt;
&lt;td&gt;
15
&lt;/td&gt;
&lt;td&gt;
1.179744
&lt;/td&gt;
&lt;td&gt;
1.100254
&lt;/td&gt;
&lt;td&gt;
1.129264
&lt;/td&gt;
&lt;td&gt;
0.548389
&lt;/td&gt;
&lt;td&gt;
-1.305309
&lt;/td&gt;
&lt;td&gt;
-1.516818
&lt;/td&gt;
&lt;td&gt;
-0.629372
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
2
&lt;/th&gt;
&lt;td&gt;
18
&lt;/td&gt;
&lt;td&gt;
1.179744
&lt;/td&gt;
&lt;td&gt;
0.821807
&lt;/td&gt;
&lt;td&gt;
0.784672
&lt;/td&gt;
&lt;td&gt;
0.273370
&lt;/td&gt;
&lt;td&gt;
-1.305309
&lt;/td&gt;
&lt;td&gt;
-1.516818
&lt;/td&gt;
&lt;td&gt;
-0.629372
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
3
&lt;/th&gt;
&lt;td&gt;
16
&lt;/td&gt;
&lt;td&gt;
1.179744
&lt;/td&gt;
&lt;td&gt;
0.699986
&lt;/td&gt;
&lt;td&gt;
0.784672
&lt;/td&gt;
&lt;td&gt;
0.270160
&lt;/td&gt;
&lt;td&gt;
-0.955578
&lt;/td&gt;
&lt;td&gt;
-1.516818
&lt;/td&gt;
&lt;td&gt;
-0.629372
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
4
&lt;/th&gt;
&lt;td&gt;
17
&lt;/td&gt;
&lt;td&gt;
1.179744
&lt;/td&gt;
&lt;td&gt;
0.682583
&lt;/td&gt;
&lt;td&gt;
0.554944
&lt;/td&gt;
&lt;td&gt;
0.287282
&lt;/td&gt;
&lt;td&gt;
-1.655041
&lt;/td&gt;
&lt;td&gt;
-1.516818
&lt;/td&gt;
&lt;td&gt;
-0.629372
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;split-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.2&lt;/span&gt; Split data&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Split the data set&lt;/strong&gt; into train and test sets (use &lt;code&gt;X_train&lt;/code&gt;, &lt;code&gt;X_test&lt;/code&gt;, &lt;code&gt;y_train&lt;/code&gt;, &lt;code&gt;y_test&lt;/code&gt;), with the first 75% of the data for training and the remaining for testing. (module: &lt;code&gt;from sklearn.model_selection import train_test_split&lt;/code&gt;)&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;X = dfs.drop([&amp;#39;mpg&amp;#39;], axis=1)
y = dfs[&amp;#39;mpg&amp;#39;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=10)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;lasso-regression&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.3&lt;/span&gt; Lasso regression&lt;/h2&gt;
&lt;p&gt;Apply &lt;strong&gt;Lasso regression&lt;/strong&gt; on the training set with the regularization parameter &lt;strong&gt;lambda = 0.5&lt;/strong&gt; (module: &lt;code&gt;from sklearn.linear_model import Lasso&lt;/code&gt;) and print the &lt;span class=&#34;math inline&#34;&gt;\(R^2\)&lt;/span&gt;-score for the training and test set. Comment on your findings.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;from sklearn.linear_model import Lasso

reg = Lasso(alpha=0.5)
reg.fit(X_train, y_train)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lasso(alpha=0.5, copy_X=True, fit_intercept=True, max_iter=1000,
normalize=False, positive=False, precompute=False, random_state=None,
selection=‘cyclic’, tol=0.0001, warm_start=False)&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;print(&amp;#39;Lasso Regression: R^2 score on training set&amp;#39;, reg.score(X_train, y_train)*100)
print(&amp;#39;Lasso Regression: R^2 score on test set&amp;#39;, reg.score(X_test, y_test)*100)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lasso Regression: R^2 score on training set 82.49741060950073
Lasso Regression: R^2 score on test set 85.49734440925533&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;lasso-with-different-lambdas&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.4&lt;/span&gt; Lasso with different lambdas&lt;/h2&gt;
&lt;p&gt;Apply the &lt;strong&gt;Lasso regression&lt;/strong&gt; on the training set with the following &lt;strong&gt;λ parameters: (0.001, 0.01, 0.1, 0.5, 1, 2, 10)&lt;/strong&gt;. Evaluate the R^2 score for all the models you obtain on both the train and test sets.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;lambdas = (0.001, 0.01, 0.1, 0.5, 1, 2, 10)
l_num = 7
pred_num = X.shape[1]

# prepare data for enumerate
coeff_a = np.zeros((l_num, pred_num))
train_r_squared = np.zeros(l_num)
test_r_squared = np.zeros(l_num)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# enumerate through lambdas with index and i
for ind, i in enumerate(lambdas):    
    reg = Lasso(alpha = i)
    reg.fit(X_train, y_train)

    coeff_a[ind,:] = reg.coef_
    train_r_squared[ind] = reg.score(X_train, y_train)
    test_r_squared[ind] = reg.score(X_test, y_test)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;plot-values-as-a-function-of-lambda&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.5&lt;/span&gt; Plot values as a function of lambda&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Plot&lt;/strong&gt; all values for both data sets (train and test &lt;span class=&#34;math inline&#34;&gt;\(R^2\)&lt;/span&gt;-values) as a function of λ. Comment on your findings.&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# Plotting
plt.figure(figsize=(18, 8))
plt.plot(train_r_squared, &amp;#39;bo-&amp;#39;, label=r&amp;#39;$R^2$ Training set&amp;#39;, color=&amp;quot;darkblue&amp;quot;, alpha=0.6, linewidth=3)
plt.plot(test_r_squared, &amp;#39;bo-&amp;#39;, label=r&amp;#39;$R^2$ Test set&amp;#39;, color=&amp;quot;darkred&amp;quot;, alpha=0.6, linewidth=3)
plt.xlabel(&amp;#39;Lamda index&amp;#39;); plt.ylabel(r&amp;#39;$R^2$&amp;#39;)
plt.xlim(0, 6)
plt.title(r&amp;#39;Evaluate lasso regression with lamdas: 0 = 0.001, 1= 0.01, 2 = 0.1, 3 = 0.5, 4= 1, 5= 2, 6 = 10&amp;#39;)
plt.legend(loc=&amp;#39;best&amp;#39;)
plt.grid()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-12-python-lasso-regression-auto/output_27_0.png&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;identify-best-lambda-and-coefficients&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.6&lt;/span&gt; Identify best lambda and coefficients&lt;/h2&gt;
&lt;p&gt;Store your test data results in a DataFrame and indentify the lambda where the &lt;span class=&#34;math inline&#34;&gt;\(R^2\)&lt;/span&gt; has it’s &lt;strong&gt;maximum value&lt;/strong&gt; in the &lt;strong&gt;test data&lt;/strong&gt;. Fit a Lasso model with this lambda parameter (use the training data) and obtain the corresponding &lt;strong&gt;regression coefficients&lt;/strong&gt;. Furthermore, obtain the &lt;strong&gt;mean squared error&lt;/strong&gt; for the test data of this model (module: &lt;code&gt;from sklearn.metrics import mean_squared_error&lt;/code&gt;)&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df_lam = pd.DataFrame(test_r_squared*100, columns=[&amp;#39;R_squared&amp;#39;])
df_lam[&amp;#39;lambda&amp;#39;] = (lambdas)
# returns the index of the row where column has maximum value.
df_lam.loc[df_lam[&amp;#39;R_squared&amp;#39;].idxmax()]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;R_squared 88.105773
lambda 0.001000
Name: 0, dtype: float64&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# Coefficients of best model
reg_best = Lasso(alpha = 0.1)
reg_best.fit(X_train, y_train)
reg_best.coef_&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;array([-0.35554113, -1.13104696, -0.00596296, -3.31741775, -0. ,
0.37914648, 0.74902885])&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;from sklearn.metrics import mean_squared_error
mean_squared_error(y_test, reg_best.predict(X_test))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.586249592807347&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;cross-validation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.7&lt;/span&gt; Cross Validation&lt;/h2&gt;
&lt;p&gt;Evaluate the performance of a &lt;strong&gt;Lasso regression&lt;/strong&gt; for different regularization parameters λ using &lt;strong&gt;5-fold cross validation&lt;/strong&gt; on the training set (module: &lt;code&gt;from sklearn.model_selection import cross_val_score&lt;/code&gt;) and plot the cross-validation (CV) &lt;span class=&#34;math inline&#34;&gt;\(R^2\)&lt;/span&gt; scores of the training and test data as a function of λ.&lt;/p&gt;
&lt;p&gt;Use the following lambda parameters:
l_min = 0.05
l_max = 0.2
l_num = 20
lambdas = np.linspace(l_min,l_max, l_num)&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;l_min = 0.05
l_max = 0.2
l_num = 20
lambdas = np.linspace(l_min,l_max, l_num)

train_r_squared = np.zeros(l_num)
test_r_squared = np.zeros(l_num)

pred_num = X.shape[1]
coeff_a = np.zeros((l_num, pred_num))&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;from sklearn.model_selection import cross_val_score

for ind, i in enumerate(lambdas):    
    reg = Lasso(alpha = i)
    reg.fit(X_train, y_train)
    results = cross_val_score(reg, X, y, cv=5, scoring=&amp;quot;r2&amp;quot;)

    train_r_squared[ind] = reg.score(X_train, y_train)    
    test_r_squared[ind] = reg.score(X_test, y_test)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# Plotting
plt.figure(figsize=(18, 8))
plt.plot(train_r_squared, &amp;#39;bo-&amp;#39;, label=r&amp;#39;$R^2$ Training set&amp;#39;, color=&amp;quot;darkblue&amp;quot;, alpha=0.6, linewidth=3)
plt.plot(test_r_squared, &amp;#39;bo-&amp;#39;, label=r&amp;#39;$R^2$ Test set&amp;#39;, color=&amp;quot;darkred&amp;quot;, alpha=0.6, linewidth=3)
plt.xlabel(&amp;#39;Lamda value&amp;#39;); plt.ylabel(r&amp;#39;$R^2$&amp;#39;)
plt.xlim(0, 19)
plt.title(r&amp;#39;Evaluate 5-fold cv with different lamdas&amp;#39;)
plt.legend(loc=&amp;#39;best&amp;#39;)
plt.grid()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-12-python-lasso-regression-auto/output_35_0.png&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;best-model&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.8&lt;/span&gt; Best Model&lt;/h2&gt;
&lt;p&gt;Finally, store your test data results in a DataFrame and identify the lambda where the &lt;span class=&#34;math inline&#34;&gt;\(R^2\)&lt;/span&gt; has it’s &lt;strong&gt;maximum value&lt;/strong&gt; in the &lt;strong&gt;test data&lt;/strong&gt;. Fit a Lasso model with this lambda parameter (use the training data) and obtain the corresponding &lt;strong&gt;regression coefficients&lt;/strong&gt;. Furthermore, obtain the &lt;strong&gt;mean squared error&lt;/strong&gt; for the test data of this model (module: &lt;code&gt;from sklearn.metrics import mean_squared_error&lt;/code&gt;)&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;df_lam = pd.DataFrame(test_r_squared*100, columns=[&amp;#39;R_squared&amp;#39;])
df_lam[&amp;#39;lambda&amp;#39;] = (lambdas)
# returns the index of the row where column has maximum value.
df_lam.loc[df_lam[&amp;#39;R_squared&amp;#39;].idxmax()]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;R_squared 87.897525
lambda 0.050000
Name: 0, dtype: float64&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;# Best Model
reg_best = Lasso(alpha = 0.144737)
reg_best.fit(X_train, y_train)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lasso(alpha=0.144737, copy_X=True, fit_intercept=True, max_iter=1000,
normalize=False, positive=False, precompute=False, random_state=None,
selection=‘cyclic’, tol=0.0001, warm_start=False)&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;from sklearn.metrics import mean_squared_error

mean_squared_error(y_test, reg_best.predict(X_test))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.635187490993961&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;reg_best.coef_&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;array([-0.34136411, -1.18223273, -0. , -3.27132984, 0. ,
0.33262331, 0.71385488])&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Correlation Tutorial with R</title>
      <link>/project/r-correlation-tutorial/</link>
      <pubDate>Sun, 11 Aug 2019 05:00:00 +0000</pubDate>
      
      <guid>/project/r-correlation-tutorial/</guid>
      <description>&lt;p&gt;Correlation is a way of measuring the extent to which two variables are related. This means we need to analyze whether as one variable increases, the other&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(1) increases,&lt;/li&gt;
&lt;li&gt;(2) decreases or&lt;/li&gt;
&lt;li&gt;(3) stays the same.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This can be done by calculating the covariance or correlation of two variables.&lt;/p&gt;

&lt;p&gt;In this &lt;a href=&#34;https://github.com/kirenz/correlation/blob/master/Correlation.md&#34; target=&#34;_blank&#34;&gt;Correlation Tutorial in R&lt;/a&gt;, we  use a small dataset to illustrate the concepts of covariance and correlation. You may also download the &lt;a href=&#34;https://github.com/kirenz/correlation/blob/master/Correlation.Rmd&#34; target=&#34;_blank&#34;&gt;Rmarkdown file&lt;/a&gt; and open it in RStudio.&lt;/p&gt;

&lt;p&gt;Check your understanding with &lt;a href=&#34;https://github.com/kirenz/correlation/blob/master/Correlation_task.pdf&#34; target=&#34;_blank&#34;&gt;multiple choice tasks&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lasso Regression with Python</title>
      <link>/project/r-lasso-regression/</link>
      <pubDate>Sun, 11 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/project/r-lasso-regression/</guid>
<<<<<<< HEAD
      <description>&lt;h1 id=&#34;lasso-regression&#34;&gt;Lasso Regression&lt;/h1&gt;
&lt;p&gt;In statistics and machine learning, lasso (least absolute shrinkage and selection operator; also Lasso or LASSO) is a regression analysis method that performs both variable selection and regularization in order to enhance the prediction accuracy and interpretability of the statistical model it produces (&lt;a href=&#34;https://en.wikipedia.org/wiki/Lasso_(statistics)&#34;&gt;Wikipedia&lt;/a&gt;).&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Lasso Regression with Python (Auto Data): &lt;a href=&#34;https://github.com/kirenz/lasso-regression/blob/master/python-lasso-regression-auto.ipynb&#34;&gt;Jupyter Notebook&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
=======
      <description>

&lt;h1 id=&#34;lasso-regression&#34;&gt;Lasso Regression&lt;/h1&gt;

&lt;p&gt;In statistics and machine learning, lasso (least absolute shrinkage and selection operator; also Lasso or LASSO) is a regression analysis method that performs both variable selection and regularization in order to enhance the prediction accuracy and interpretability of the statistical model it produces (&lt;a href=&#34;https://en.wikipedia.org/wiki/Lasso_(statistics)&#34; target=&#34;_blank&#34;&gt;Wikipedia&lt;/a&gt;).&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Lasso Regression with Python (Auto Data): &lt;a href=&#34;https://github.com/kirenz/lasso-regression/blob/master/python-lasso-regression-auto.ipynb&#34; target=&#34;_blank&#34;&gt;Jupyter Notebook&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
>>>>>>> 5b4f11a004ab5d532500113c7a94cd15366cfa9b
</description>
    </item>
    
    <item>
      <title>Time Series Analysis with Python</title>
      <link>/project/python-time-series/</link>
      <pubDate>Sun, 11 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/project/python-time-series/</guid>
<<<<<<< HEAD
      <description>&lt;h1 id=&#34;time-series-analysis-with-python&#34;&gt;Time Series Analysis with Python&lt;/h1&gt;
=======
      <description>

&lt;h1 id=&#34;time-series-analysis-with-python&#34;&gt;Time Series Analysis with Python&lt;/h1&gt;

>>>>>>> 5b4f11a004ab5d532500113c7a94cd15366cfa9b
&lt;p&gt;Time series analysis can be used in a multitude of business applications for forecasting a quantity into the future and explaining its historical patterns. Here are just a few examples of possible use cases:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Explaining seasonal patterns in sales&lt;/li&gt;
&lt;li&gt;Predicting the expected number of incoming or churning customers&lt;/li&gt;
&lt;li&gt;Estimating the effect of a newly launched product on number of sold units&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Introduction to Time Series Analysis with Python: Fit &lt;strong&gt;ARIMA&lt;/strong&gt; and &lt;strong&gt;SARIMAX-Models&lt;/strong&gt; with &lt;code&gt;Statsmodel&lt;/code&gt;: &lt;a href=&#34;https://github.com/kirenz/time-series-analysis/blob/master/time-series-first-steps.ipynb&#34; target=&#34;_blank&#34;&gt;Jupyter Notebook&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Introduction to Facebook&amp;rsquo;s time series analysis modul &lt;strong&gt;Prophet&lt;/strong&gt;: &lt;a href=&#34;https://github.com/kirenz/time-series-analysis/blob/master/Prophet.ipynb&#34; target=&#34;_blank&#34;&gt;Jupyter Notebook&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>Deskriptive Statistik in R</title>
      <link>/post/2019-08-01-r-descriptive-statistics/</link>
      <pubDate>Sun, 04 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-08-01-r-descriptive-statistics/</guid>
      <description>

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#deskriptive-statistik-in-r&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1&lt;/span&gt; Deskriptive Statistik in R&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#datenimport&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.1&lt;/span&gt; Datenimport&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#deskriptive-statistiken&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.2&lt;/span&gt; Deskriptive Statistiken&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mittelwert&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.2.1&lt;/span&gt; Mittelwert&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#standardabweichung&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.2.2&lt;/span&gt; Standardabweichung&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#getrimmter-mittelwert&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.2.3&lt;/span&gt; Getrimmter Mittelwert&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#schiefe&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.2.4&lt;/span&gt; Schiefe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#kurtosis&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.2.5&lt;/span&gt; Kurtosis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#standardfehler&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.2.6&lt;/span&gt; Standardfehler&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;deskriptive-statistik-in-r&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;1&lt;/span&gt; Deskriptive Statistik in R&lt;/h1&gt;
&lt;p&gt;In diesem Beitrag wird die Berechnung einfacher deskriptiver Statistiken und die Visualisierung von Verteilungen in R am Beispiel des Datensatzes “Advertising” behandelt.&lt;/p&gt;
&lt;div id=&#34;datenimport&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.1&lt;/span&gt; Datenimport&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Datensatz: Advertising.csv&lt;/li&gt;
&lt;li&gt;Variablen: &lt;em&gt;TV&lt;/em&gt;, &lt;em&gt;radio&lt;/em&gt;, &lt;em&gt;newspaper&lt;/em&gt; = jeweils Werbeausgaben in Dollar; &lt;em&gt;sales&lt;/em&gt; = Produkte in Tausend Einheiten&lt;/li&gt;
&lt;li&gt;Abhängige Variable (dependent variable, response): &lt;em&gt;sales&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Unabhängige Variablen (independent variables, predictors): &lt;em&gt;TV&lt;/em&gt;, &lt;em&gt;radio&lt;/em&gt;, &lt;em&gt;newspaper&lt;/em&gt;, &lt;em&gt;sales&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Zunächts möchten wir uns einen Überblick über die Daten verschaffen. Dafür importieren wir die Daten und prüfen, ob die Skalenniveaus korrekt sind. Für die weiteren Berechnungen wird die Variable X1 nicht benötigt, weshalb wir diese löschen.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
# Daten importieren
Advertising &amp;lt;- read_csv(&amp;quot;https://raw.githubusercontent.com/kirenz/datasets/master/advertising.csv&amp;quot;)
# Überblick über die Daten verschaffen (Skalenniveaus prüfen)
head(Advertising)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 5
##      X1    TV radio newspaper sales
##   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1     1 230.   37.8      69.2  22.1
## 2     2  44.5  39.3      45.1  10.4
## 3     3  17.2  45.9      69.3   9.3
## 4     4 152.   41.3      58.5  18.5
## 5     5 181.   10.8      58.4  12.9
## 6     6   8.7  48.9      75     7.2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Bereinigung der Daten
Advertising$X1 &amp;lt;- NULL&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;deskriptive-statistiken&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.2&lt;/span&gt; Deskriptive Statistiken&lt;/h2&gt;
&lt;p&gt;Ausgabe unterschiedlicher deskriptiver Statistiken:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(psych)

psych::describe(Advertising) &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##           vars   n   mean    sd median trimmed    mad min   max range
## TV           1 200 147.04 85.85 149.75  147.20 108.82 0.7 296.4 295.7
## radio        2 200  23.26 14.85  22.90   23.00  19.79 0.0  49.6  49.6
## newspaper    3 200  30.55 21.78  25.75   28.41  23.13 0.3 114.0 113.7
## sales        4 200  14.02  5.22  12.90   13.78   4.82 1.6  27.0  25.4
##            skew kurtosis   se
## TV        -0.07    -1.24 6.07
## radio      0.09    -1.28 1.05
## newspaper  0.88     0.57 1.54
## sales      0.40    -0.45 0.37&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Hinweise zu den Kennzahlen:
&lt;ul&gt;
&lt;li&gt;vars: Nummer der Variable&lt;/li&gt;
&lt;li&gt;n: Anzahl der Beobachtungen&lt;/li&gt;
&lt;li&gt;mean: arithmetischer Mittelwert&lt;/li&gt;
&lt;li&gt;sd: empirische Standardabweichung&lt;/li&gt;
&lt;li&gt;median: Median&lt;/li&gt;
&lt;li&gt;trimmed: getrimmter Mittelwert&lt;/li&gt;
&lt;li&gt;mad: Mittlere absolute Abweichung vom Median&lt;/li&gt;
&lt;li&gt;min: kleinster Beobachtungswert&lt;/li&gt;
&lt;li&gt;max: größter Beobachtungswert&lt;/li&gt;
&lt;li&gt;range: Spannweite&lt;/li&gt;
&lt;li&gt;skew: Schiefe&lt;/li&gt;
&lt;li&gt;kurtosis: Wölbung&lt;/li&gt;
&lt;li&gt;se = Standardfehler&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id=&#34;mittelwert&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.2.1&lt;/span&gt; Mittelwert&lt;/h3&gt;
&lt;p&gt;Bei der Berechnung des &lt;em&gt;arithmetischen Mittelwerts&lt;/em&gt; in R sollte immer die Anweisung gegeben werden, fehlende Werte auszuschließen (na.rm = “remove values which are not available”). Ansonsten stoppt R bei fehlenden Werten die Berechnung und gibt eine Fehlermeldung aus.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mean_sales &amp;lt;- mean(Advertising$sales, na.rm = TRUE)
print(paste0(&amp;quot;Mittelwert der Variable Sales: &amp;quot;, mean_sales))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Mittelwert der Variable Sales: 14.0225&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;standardabweichung&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.2.2&lt;/span&gt; Standardabweichung&lt;/h3&gt;
&lt;p&gt;Die Standardabweichung ist ein häufig verwendetes Streuungsmaß und beschreibt die mittlere Abweichung der einzelnen Messwerte vom empirischen Mittelwert. Die Standardabweichung ist die positive Wurzel der empirischen Varianz. Die Varianz einer Stichprobe wird wie folgt berechnet:
&lt;span class=&#34;math display&#34;&gt;\[s^{2} = \frac{\sum_{i=1}^{n} \left(x_{i} - \bar{x}\right)^{2}} {n-1}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Berechnung der Standardabweichung: &lt;span class=&#34;math display&#34;&gt;\[s = \sqrt{\frac{\sum\limits_{i=1}^{n} \left(x_{i} - \bar{x}\right)^{2}} {n-1}}\]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;var_sales &amp;lt;- var(Advertising$sales, na.rm = TRUE)
print(paste0(&amp;quot;Varianz der Variable Sales: &amp;quot;, round(var_sales, 2)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Varianz der Variable Sales: 27.22&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sd_sales &amp;lt;-  sd(Advertising$sales, na.rm = TRUE)
print(paste0(&amp;quot;Standardabweichung der Variable Sales: &amp;quot;, round(sd_sales,2)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Standardabweichung der Variable Sales: 5.22&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;getrimmter-mittelwert&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.2.3&lt;/span&gt; Getrimmter Mittelwert&lt;/h3&gt;
&lt;p&gt;Bei dem &lt;em&gt;getrimmten Mittelwert&lt;/em&gt; wird ein bestimmer Anteil der größten und kleinsten Beobachtungen - hier oberhalb des 90% Quantils und unterhalb des 10 % Quantils - ignoriert. Damit sollen Ausreißer aus der Berechnung des Mittelwerts ausgeschlossen werden. Der getrimmte Mittelwert kann wie folgt in R berechnet werden:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mean_trim_sales &amp;lt;- mean(Advertising$sales, trim = 0.1, na.rm = TRUE)
print(paste0(&amp;quot;Getrimmter Mittelwert der Variable Sales: &amp;quot;, round(mean_trim_sales, 2)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Getrimmter Mittelwert der Variable Sales: 13.78&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;schiefe&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.2.4&lt;/span&gt; Schiefe&lt;/h3&gt;
&lt;p&gt;Die &lt;em&gt;Schiefe&lt;/em&gt; ist eine statistische Kennzahl, die die Art und Stärke der Asymmetrie einer Wahrscheinlichkeitsverteilung beschreibt. Sie zeigt an, ob und wie stark die Verteilung nach rechts (positive Schiefe) oder nach links (negative Schiefe) geneigt ist. Jede nicht symmetrische Verteilung heißt schief.&lt;/p&gt;
&lt;p&gt;Darstellung der Verteilung in einem Histogramm:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)
# Vorlage für die Erstellung von plots in ggplot2 
plot_1 &amp;lt;-  theme_bw() +
        theme(axis.text.x = element_text(angle = 0, size = 8, family=&amp;quot;Arial&amp;quot;, colour=&amp;#39;black&amp;#39;),
        axis.text.y = element_text(angle = 0, size = 8, family=&amp;quot;Arial&amp;quot;, colour=&amp;#39;black&amp;#39;),
        axis.title = element_text(size=8, face=&amp;quot;bold&amp;quot;, family=&amp;quot;Arial&amp;quot;, colour=&amp;#39;black&amp;#39;),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.title=element_text(hjust=0, size=10,  family=&amp;quot;Arial&amp;quot;, face=&amp;quot;bold&amp;quot;, colour=&amp;#39;black&amp;#39;))

ggplot(Advertising, aes(sales)) +
  geom_histogram(binwidth = 2, color=&amp;quot;red&amp;quot;, alpha=.2) +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) +
  labs(title=&amp;quot;Histogramm für Sales&amp;quot;, x=&amp;quot;Sales&amp;quot;, y=&amp;quot;Anzahl&amp;quot;) +
  plot_1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-01-r-descriptive-statistics/index_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Darstellung der Verteilung in einer Dichtefunktion:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)

ggplot(Advertising, aes(sales)) +
  geom_density(fill=&amp;quot;grey&amp;quot;,alpha=.2 ) +
  geom_vline(aes(xintercept=mean(sales, na.rm=TRUE)), color=&amp;quot;red&amp;quot;, linetype=&amp;quot;dotted&amp;quot;, size=0.6) +
  geom_vline(aes(xintercept=median(sales, na.rm=TRUE)), color=&amp;quot;red&amp;quot;, linetype=&amp;quot;dotted&amp;quot;, size=0.6) +
  geom_text(aes(x=median(sales), y=0.02), colour = &amp;quot;grey&amp;quot;, size =3,  
             label=round(mean(Advertising$sales), digits=2), hjust=-1, family=&amp;quot;Arial&amp;quot;) +
  geom_text(aes(x=mean(sales), y=0.02), hjust=-0.7, colour = &amp;quot;grey&amp;quot;, size = 3, label=&amp;quot;Mittelwert&amp;quot;, family=&amp;quot;Arial&amp;quot;) +
  geom_text(aes(x=median(sales), y=0.005), colour = &amp;quot;grey&amp;quot;, size =3, 
             label=round(median(Advertising$sales), digits=2), hjust=1 , family=&amp;quot;Arial&amp;quot;) +
  geom_text(aes(x=median(sales), y=0.01), colour = &amp;quot;grey&amp;quot;, size = 3, label=&amp;quot;Median&amp;quot;, hjust=1, family=&amp;quot;Arial&amp;quot;) +
  labs(x=&amp;quot;Produktabsatz (in Tausend Einheiten)&amp;quot;, y = &amp;quot;Dichte&amp;quot;, title = &amp;quot;Wahrscheinlichkeitsdichtefunktion&amp;quot;) +
  plot_1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-08-01-r-descriptive-statistics/index_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;In der Abbildung kann man erkennen, dass es sich um eine asymmetrische Verteilung handelt (d.h. es liegt eine Abweichung von der Normalverteilung vor). Konkret handelt es sich um eine rechtsschiefe Verteilung (Mittelwert &amp;gt; Median; Schiefe = + 0.40).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;kurtosis&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.2.5&lt;/span&gt; Kurtosis&lt;/h3&gt;
&lt;p&gt;Die Abweichung des Verlaufs einer Verteilung vom Verlauf einer Normalverteilung wird &lt;em&gt;Kurtosis&lt;/em&gt; (Wölbung) genannt. Sie gibt an, wie spitz die Kurve verläuft. Unterschieden wird zwischen positiver, spitz zulaufender (leptokurtische Verteilung) und negativer, flacher (platykurtische Verteilung) Kurtosis. Die Kurtosis zählt zu den zentralen Momenten einer Verteilung, mittels derer der Kurvenverlauf definiert wird. Eine Kurtosis mit Wert 0 ist normalgipflig (mesokurtisch), ein Wert größer 0 ist steilgipflig und ein Wert unter 0 ist flachgipflig.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;standardfehler&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.2.6&lt;/span&gt; Standardfehler&lt;/h3&gt;
&lt;p&gt;Der &lt;em&gt;Standardfehler&lt;/em&gt; ein Maß für die durchschnittliche Abweichung des geschätzten Parameterwertes vom wahren Parameterwert. Je kleiner der Standardfehler ist, desto genauer kann der unbekannte Parameter der Population mit Hilfe der Schätzfunktion geschätzt werden. Der Standardfehler hängt unter anderem von dem Stichprobenumfang und der Varianz ab. Allgemein gilt: Je größer der Stichprobenumfang, desto kleiner der Standardfehler; je kleiner die Varianz, desto kleiner der Standardfehler.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Linear Regression Tutorial with Python</title>
      <link>/project/python-linear-regression/</link>
      <pubDate>Sun, 04 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/project/python-linear-regression/</guid>
<<<<<<< HEAD
      <description>&lt;h1 id=&#34;linear-regression-tutorial-in-python&#34;&gt;Linear Regression Tutorial in Python&lt;/h1&gt;
=======
      <description>

&lt;h1 id=&#34;linear-regression-tutorial-in-python&#34;&gt;Linear Regression Tutorial in Python&lt;/h1&gt;

>>>>>>> 5b4f11a004ab5d532500113c7a94cd15366cfa9b
&lt;p&gt;Linear regression is the fundamental starting point for all regression methods. In this Jupyter Notebook, we fit a regression model in Python and take a closer look at the following topics:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Histogramms&lt;/li&gt;
&lt;li&gt;Boxplots&lt;/li&gt;
&lt;li&gt;Mean&lt;/li&gt;
&lt;li&gt;Standard deviation&lt;/li&gt;
&lt;li&gt;Mean squared error&lt;/li&gt;
&lt;li&gt;$R^2$&lt;/li&gt;
&lt;li&gt;Pearson&amp;rsquo;s correlation coefficient&lt;/li&gt;
&lt;li&gt;F-Statistic&lt;/li&gt;
&lt;li&gt;Standard error&lt;/li&gt;
&lt;li&gt;Confidence interval&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Download the linear regression tutorial Jupyter Notebook in &lt;a href=&#34;https://github.com/kirenz/linear-regression/blob/master/python-regression-tutorial.ipynb&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt; and open the file in Jupyter Notebook.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Free books to learn Data Science &amp; Statistics with R</title>
      <link>/project/r-data-science-statistics/</link>
      <pubDate>Thu, 01 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/project/r-data-science-statistics/</guid>
<<<<<<< HEAD
      <description>&lt;p&gt;&amp;ldquo;&lt;strong&gt;R for Data Science&lt;/strong&gt;&amp;rdquo; offers an excellent introduction into data science in R with a focus on the popular package collection &lt;a href=&#34;https://www.tidyverse.org&#34;&gt;tidyverse&lt;/a&gt;. See how the &lt;em&gt;tidyverse&lt;/em&gt; makes data science faster, easier and more fun:&lt;/p&gt;
=======
      <description>&lt;p&gt;&amp;ldquo;&lt;strong&gt;R for Data Science&lt;/strong&gt;&amp;rdquo; offers an excellent introduction into data science in R with a focus on the popular package collection &lt;a href=&#34;https://www.tidyverse.org&#34; target=&#34;_blank&#34;&gt;tidyverse&lt;/a&gt;. See how the &lt;em&gt;tidyverse&lt;/em&gt; makes data science faster, easier and more fun:&lt;/p&gt;

>>>>>>> 5b4f11a004ab5d532500113c7a94cd15366cfa9b
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://r4ds.had.co.nz&#34; target=&#34;_blank&#34;&gt;Wickham, H., &amp;amp; Grolemund, G. (2016). R for data science: import, tidy, transform, visualize, and model data. O&amp;rsquo;Reilly Media, Inc.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;ldquo;&lt;strong&gt;An Introduction to Statistical Learning&lt;/strong&gt;&amp;rdquo; provides an accessible overview of the field of statistical learning with applications in R. This book presents important modeling and prediction techniques, along with relevant applications. Topics include linear regression, classification, resampling methods, shrinkage approaches, tree-based methods, support vector machines, clustering, and more:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.statlearning.com&#34; target=&#34;_blank&#34;&gt;James, G., Witten, D., Hastie, T., &amp;amp; Tibshirani, R. (2013). An introduction to statistical learning with applications in R (Corr. 7th printing 2017). New York: Springer.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;ldquo;&lt;strong&gt;Statistical Thinking for the 21 Century&lt;/strong&gt;&amp;rdquo; and &amp;ldquo;&lt;strong&gt;Modern Dive: Statistical Inference via Data Science&lt;/strong&gt;&amp;rdquo; are both open-source digital textbooks which provide a great introduction into the fundamentals of modern quantitative methods which take advantage of today’s increased computing power to solve statistical problems with R:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://statsthinking21.org&#34; target=&#34;_blank&#34;&gt;Poldrack, R. A. (2019). Statistical Thinking for the 21 Century. http://thinkstats.org.&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://moderndive.com/index.html#sec:intro-for-students&#34; target=&#34;_blank&#34;&gt;Ismay, C. &amp;amp; Kim, A. Y. (2019). Modern Dive: Statistical Inference via Data Science. https://moderndive.com&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
